\documentclass[11pt]{article}


\usepackage[margin = 1in]{geometry}
\usepackage{article_macros}
\usepackage{authblk}
\usepackage{tikz}



\theoremstyle{definition}
\newtheorem{algorithm}{Algorithm}
\newtheorem{construction}[theorem]{Construction}

\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}

\newcommand{\cas}{\mathrm{cas}}
\newcommand{\cht}{\mathsf{H}}
\newcommand{\qht}{\mathsf{QHT}}
\newcommand{\cft}{\mathsf{F}}
\newcommand{\qft}{\mathsf{QFT}}
\newcommand{\comph}{\mathsf{cmpIndex}}
\newcommand{\gen}{\mathsf{Gen}}
\newcommand{\ver}{\mathsf{Ver}}







\title{Quantum Walks and Application to Quantum Money}

\author{Jake Doliskani\thanks{\tt jake.doliskani@mcmaster.ca} }
% \author{Morteza Mirzaei\thanks{\tt mirzam48@mcmaster.ca} }
\author{Seyed Ali Mousavi\thanks{\tt mousas26@mcmaster.ca} }
\affil{Department of Computing and Software, McMaster University}


\date{}
\sloppy
\allowdisplaybreaks










\begin{document}
\maketitle



\newpage
\section{Introduction to Quantum Computation}
\label{sec:intro}


\section*{Introduction}

Quantum computing is a revolutionary field that combines quantum mechanics and information theory to redefine computation and information processing. In the latter part of the 20th century, scientists explored the fusion of quantum mechanics and information theory, leading to the birth of quantum information science. This field challenges the classical view of computation by introducing novel concepts like quantum bits (qubits), entanglement, and quantum superposition, which have enabled new algorithms and protocols that outpace their classical counterparts in specific tasks. Classical computers are grounded in bits, which take binary values (0 or 1). Quantum computing introduces the qubit, a fundamental unit of quantum information that can exist in a superposition of states, such as 0 and 1 simultaneously. This foundational difference enables quantum computers to process information in fundamentally new ways. Unlike technologies like DNA computing or optical computing, which describe changes in the physical substrate while retaining classical computational principles, quantum computing changes the computational paradigm itself. A quantum computer uses the principles of quantum mechanics, such as superposition and entanglement, rather than classical mechanics, to process information. In the 1980s, pioneers like Richard Feynman and David Deutsch recognized that certain quantum phenomena could not be efficiently simulated on classical computers. These insights led to the exploration of quantum Turing machines and quantum circuit models, which provided a theoretical framework for quantum computing. The discovery of quantum gates and their role in quantum algorithms formalized the field.

Early quantum algorithms demonstrated that quantum computing could solve certain problems more efficiently than classical methods. Notably, in 1994, Peter Shor introduced a polynomial-time quantum algorithm for integer factorization, which threatened classical cryptographic protocols relying on the difficulty of factoring large integers. Entanglement, a uniquely quantum phenomenon, allows particles to exhibit correlations that defy classical explanation. This property is crucial for many quantum algorithms and protocols, as it enables quantum computers to process and store information in a way that classical computers cannot. Two notable algorithms underscore the potential of quantum computing: Shor’s Algorithm, which efficiently factors integers, undermining RSA encryption and other cryptographic systems based on the hardness of factoring, and Grover’s Algorithm, which provides a quadratic speedup for unstructured search problems, such as searching an unsorted database. These algorithms exemplify the theoretical advantages of quantum computing over classical approaches, even though practical implementations remain challenging.

Quantum systems are fragile and susceptible to decoherence, where quantum states lose their coherence due to interactions with the environment. This makes maintaining quantum states for computation a significant challenge. Quantum error correction methods were developed to address decoherence and other quantum noise. The breakthrough work of Shor and Steane in the mid-1990s introduced error-correction codes that allowed reliable computation despite quantum noise. Building scalable quantum computers requires advances in hardware and experimental techniques. As of now, only small-scale quantum systems with a few qubits have been implemented successfully in laboratories. Quantum computing does not offer universal speedups for all problems. For example, Grover’s algorithm provides only a quadratic speedup for unstructured search, and certain problems remain equally challenging for both quantum and classical computers.

Quantum key distribution protocols, like BB84 and Ekert’s protocol, offer provably secure methods for communication based on the principles of quantum mechanics. Unlike classical cryptography, which relies on computational assumptions, quantum cryptography guarantees security through physical principles. The quantum perspective has provided new insights into classical computing and inspired novel classical algorithms. It has also advanced simulation techniques for quantum systems, benefiting fields like material science and chemistry. Quantum information processing has deepened our understanding of quantum mechanics, shedding light on foundational questions about quantum measurement and entanglement. For example, experiments testing Bell’s inequalities have confirmed the non-classical correlations predicted by quantum theory.

While practical quantum computing is still in its infancy, significant progress has been made. Quantum hardware companies like IBM, Google, and Rigetti have developed small-scale quantum processors capable of performing limited computations. Platforms such as Qiskit and Cirq enable researchers to experiment with quantum programming and algorithm development. Efforts to build scalable, fault-tolerant quantum computers are ongoing, alongside investigations into alternative models of quantum computation, such as topological and cluster-state quantum computing. Despite these advances, many open questions remain about the scope and ultimate power of quantum computation. While quantum computers will not replace classical ones for all tasks, they promise to revolutionize fields where their unique capabilities provide exponential speedups or new forms of computation.

Quantum computing represents a profound shift in how we understand and leverage computation. By replacing classical mechanics with quantum mechanics as the foundation for processing information, quantum computing has opened new avenues for scientific discovery and technological innovation. While challenges persist, the theoretical and experimental advances made thus far underscore the transformative potential of this exciting field.


\section*{Foundations of Quantum Computation}



\section*{Understanding a Qubit}
A qubit (quantum bit) is the fundamental unit of quantum information, analogous to a classical bit. However, unlike a classical bit, which can only exist in one of two definite states ($0$ or $1$), a qubit can exist in a linear combination, or superposition, of both states simultaneously. Mathematically, the state of a single qubit is represented as:

\begin{equation}
|\psi\rangle = \alpha |0\rangle + \beta |1\rangle
\end{equation}

Here:
\begin{itemize}
    \item $|0\rangle$ and $|1\rangle$ are the basis states (analogous to $0$ and $1$ in classical computing).
    \item $\alpha$ and $\beta$ are complex numbers known as probability amplitudes.
\end{itemize}

The normalization condition \(|\alpha|^2 + |\beta|^2 = 1\) ensures that the probabilities of measuring the qubit in either the $|0\rangle$ or $|1\rangle$ state sum to 1.

The qubit's unique ability to exist in a superposition of states is what gives quantum computers their immense computational potential, enabling them to process and store information in fundamentally different ways than classical computers.

\section*{Superposition}
Superposition is a quantum phenomenon where a qubit exists in a combination of multiple states simultaneously. For example, a qubit in the state:

\begin{equation}
|\psi\rangle = \frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle
\end{equation}

is in an equal superposition of $|0\rangle$ and $|1\rangle$. This means that if we measure the qubit, there is an equal probability (50\%) of observing it in either state.

Key properties of superposition:
\begin{itemize}
    \item \textbf{Parallelism:} When a quantum system is in superposition, it can perform computations for all possible states simultaneously. For instance, a single qubit can encode two states ($|0\rangle$ and $|1\rangle$) at the same time, while $n$ qubits can encode $2^n$ states.
    \item \textbf{Measurement Collapse:} When a qubit in superposition is measured, it collapses into one of its basis states, $|0\rangle$ or $|1\rangle$, with a probability given by $|\alpha|^2$ and $|\beta|^2$, respectively.
\end{itemize}

Superposition allows quantum systems to explore multiple possibilities in parallel, which is critical for quantum algorithms such as Grover's search or Shor's factoring.

\section*{Entanglement}
Entanglement is a uniquely quantum phenomenon where two or more qubits become correlated in such a way that the state of one qubit is directly related to the state of the other, regardless of the physical distance between them. When qubits are entangled, the measurement of one qubit instantly determines the state of the other.

An example of an entangled state for two qubits is the Bell state:

\begin{equation}
|\psi\rangle = \frac{1}{\sqrt{2}} (|00\rangle + |11\rangle)
\end{equation}

Here:
\begin{itemize}
    \item $|00\rangle$ means both qubits are in the $|0\rangle$ state.
    \item $|11\rangle$ means both qubits are in the $|1\rangle$ state.
\end{itemize}

If one qubit is measured to be $|0\rangle$, the other qubit will instantly collapse to $|0\rangle$, and similarly for $|1\rangle$, regardless of the distance between them.

Key features of entanglement:
\begin{itemize}
    \item \textbf{Non-Local Correlations:} Entanglement defies classical intuition, as it suggests that measurement outcomes are correlated even across vast distances, a phenomenon supported by experiments validating Bell's Theorem.
    \item \textbf{Applications:} Entanglement is a resource for many quantum technologies, including quantum teleportation, quantum cryptography (e.g., secure communication via the BB84 protocol), and quantum error correction.
\end{itemize}

Entanglement, along with superposition, forms the backbone of quantum computing and quantum communication, enabling capabilities that are impossible in the classical world.




\subsection*{Quantum Gates and Circuits}


Quantum logic gates are the fundamental building blocks of quantum circuits, manipulating qubits—the basic units of quantum information. Unlike classical logic gates, quantum gates are reversible and represented by unitary matrices, ensuring the preservation of quantum information.

\subsection*{Key Quantum Logic Gates}

\subsubsection*{1. Pauli-X Gate (NOT Gate)}
\textbf{Operation:} Flips the state of a qubit from $|0\rangle$ to $|1\rangle$ and vice versa. \\
\textbf{Matrix Representation:}
\[
X = 
\begin{bmatrix}
0 & 1 \\
1 & 0
\end{bmatrix}
\]

\subsubsection*{2. Hadamard Gate (H Gate)}
\textbf{Operation:} Creates a superposition state, transforming $|0\rangle$ into $\frac{|0\rangle + |1\rangle}{\sqrt{2}}$ and $|1\rangle$ into $\frac{|0\rangle - |1\rangle}{\sqrt{2}}$. \\
\textbf{Matrix Representation:}
\[
H = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 & 1 \\
1 & -1
\end{bmatrix}
\]

\subsubsection*{3. Controlled-NOT Gate (CNOT Gate)}
\textbf{Operation:} A two-qubit gate that flips the state of the target qubit if the control qubit is in the state $|1\rangle$. \\
\textbf{Matrix Representation:}
\[
CNOT =
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0
\end{bmatrix}
\]


\subsection*{Universal Gates}
A set of gates is considered \textbf{universal} if any unitary operation can be approximated to arbitrary precision using a sequence of gates from this set. For example, single-qubit rotation gates combined with the CNOT gate form a universal set, enabling the construction of any quantum algorithm.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction to Quantum Walks}


The concept of a \textit{quantum walk} is a quantum analog of the classical random walk and plays a significant role in quantum algorithms. There are two main types of quantum walks: \textit{continuous-time} and \textit{discrete-time} quantum walks, both of which exhibit behaviors that are significantly different from classical random walks.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Continuous-Time Quantum Walks}


Classical continuous-time random walks (Markov chains) are a foundational concept in stochastic processes, where time is treated as a continuous variable. In this framework, a walker moves from one vertex of a graph to an adjacent vertex at any time, with probabilities evolving over time. The probability of the walker being at a vertex can be visualized as a liquid seeping from one vertex to its neighbors. Initially, the walker is most likely to be found at the starting vertex, but as time progresses, the probability shifts to neighboring vertices. This dynamic is governed by a constant transition rate \( \gamma \), uniform across all vertices and time.

To model this mathematically, the probability of transitioning from one vertex to another in an infinitesimal time interval \( \Delta t \) is proportional to \( \gamma \Delta t \). For a vertex \( x_j \) with degree \( d_j \) (the number of neighboring vertices), the probability of the walker staying on \( x_j \) is 

\[
1 - d_j \gamma \Delta t,
\]

while the probability of transitioning to a neighboring vertex is 

\[
\gamma \Delta t.
\]

The evolution of probabilities over time is captured by the transition matrix \( M(t) \), where the entry \( M_{ij}(t) \) represents the probability of transitioning from vertex \( x_j \) to vertex \( x_i \) in time \( t \). The dynamics of the system are described by a differential equation derived from the transition matrix and an auxiliary matrix \( H \), known as the generating matrix. This equation, 

\[
\frac{dM(t)}{dt} = -H M(t),
\]

has a solution expressed as 

\[
M(t) = e^{-Ht},
\]

which allows for the computation of probability distributions at any given time. The solution is verified using the Taylor series expansion of the exponential function.

The passage from classical continuous-time Markov chains to quantum walks involves a standard quantization process. In classical random walks, probabilities evolve via the transition matrix \( M \). In contrast, the quantization process replaces the vector of probabilities with a state vector (probability amplitudes) and the non-unitary transition matrix with a unitary evolution operator, as required by quantum mechanics. This involves transforming the generating matrix \( H \) into a Hermitian operator and then constructing a unitary operator 

\[
U(t) = e^{-iHt}
\]

by multiplying \( H \) with the imaginary unit \( i \).

In a continuous-time quantum walk, the quantum state evolves over time according to the unitary operator \( U(t) \). If the initial state of the system is \( |\psi(0)\rangle \), the state at time \( t \) is given by 

\[
|\psi(t)\rangle = U(t) |\psi(0)\rangle.
\]

The probability distribution for observing the walker at a specific vertex \( k \) is computed as 

\[
p_k = |\langle k | \psi(t) \rangle|^2,
\]

where \( |k\rangle \) represents the state corresponding to vertex \( k \).

The continuous-time quantum walk introduces several key differences from its classical counterpart. Unlike classical random walks, which rely on probabilities, quantum walks involve probability amplitudes, enabling interference effects. These effects allow quantum walks to explore the graph more efficiently, leading to applications in quantum algorithms with speedups over classical approaches. Additionally, the transition matrix in classical random walks is replaced with a Hermitian operator in the quantum case, ensuring unitary evolution.



\subsection*{Example: Continuous-Time Quantum Walk on the Line}

To illustrate the behavior of continuous-time quantum walks, consider the example of a particle evolving on the \textit{infinite one-dimensional lattice}, also known as the \textit{integer line}. In this graph, the vertices are labeled by integers \( \mathbb{Z} \), and each vertex \( n \in \mathbb{Z} \) is connected to its immediate neighbors \( n-1 \) and \( n+1 \). The adjacency matrix \( A \) for this graph has entries:
\[
A_{i,j} =
\begin{cases}
1 & \text{if } |i - j| = 1, \\
0 & \text{otherwise}.
\end{cases}
\]

Let the walker initially be located at the origin, so the initial state is \( |\psi(0)\rangle = |0\rangle \). The quantum evolution of the system is governed by the Schrödinger equation:
\[
i \frac{d}{dt} |\psi(t)\rangle = A |\psi(t)\rangle,
\]
with the solution:
\[
|\psi(t)\rangle = e^{-iAt} |\psi(0)\rangle.
\]

For this specific graph, the amplitude of being at position \( n \) at time \( t \) has an elegant closed-form expression:
\[
\psi_n(t) = i^n J_n(2t),
\]
where \( J_n \) is the \textit{Bessel function of the first kind} of order \( n \). The corresponding probability of finding the walker at vertex \( n \) at time \( t \) is:
\[
p_n(t) = |\psi_n(t)|^2 = |J_n(2t)|^2.
\]

This probability distribution displays quintessential quantum behavior: it is \textbf{non-Gaussian}, \textbf{oscillatory}, and \textbf{spreads faster} than in the classical case. In contrast to the diffusive behavior of classical walks, where the standard deviation grows as \( \sigma(t) \propto \sqrt{t} \), the quantum walk exhibits \textit{ballistic spread} with \( \sigma(t) \propto t \).

These interference-driven properties make CTQWs particularly powerful for applications in quantum information and quantum algorithms, where the speed and spread of information are crucial.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Discrete-Time Quantum Walks}



Discrete-time quantum walks (DTQWs) serve as the discrete counterpart of quantum random walks and are particularly useful for algorithmic constructions in quantum computing. Unlike continuous-time quantum walks, DTQWs require an additional coin degree of freedom to preserve unitarity in the evolution. In this section, we explore the discrete-time coined quantum walk on the infinite one-dimensional lattice (integer line), which provides a clear and tractable example of how interference and superposition govern quantum behavior.

\subsubsection*{Hilbert Space and Coin Space}

The state space of the system is the tensor product \( \mathcal{H} = \mathcal{H}_C \otimes \mathcal{H}_P \), where:
\begin{itemize}
    \item \( \mathcal{H}_C \) is the 2-dimensional Hilbert space of the quantum coin, with basis states \( \{|0\rangle, |1\rangle\} \), often interpreted as ``spin up'' and ``spin down''.
    \item \( \mathcal{H}_P \) is the position Hilbert space, spanned by \( \{|n\rangle : n \in \mathbb{Z}\} \), representing the particle's location on the integer line.
\end{itemize}

\subsubsection*{Coin and Shift Operators}

The walk consists of two operations applied in sequence:
\begin{enumerate}
    \item \textbf{Coin operator \( C \)}: A unitary operator acting on \( \mathcal{H}_C \), typically chosen to create superposition. A common choice is the \textit{Hadamard coin}:
    \[
    H = \frac{1}{\sqrt{2}} \begin{bmatrix}
    1 & 1 \\
    1 & -1
    \end{bmatrix}.
    \]
    \item \textbf{Shift operator \( S \)}: A unitary operator on \( \mathcal{H}_C \otimes \mathcal{H}_P \) that moves the walker depending on the coin state:
    \[
    S|0\rangle|n\rangle = |0\rangle|n + 1\rangle, \quad
    S|1\rangle|n\rangle = |1\rangle|n - 1\rangle.
    \]
\end{enumerate}

One full step of the walk is implemented by applying the unitary operator:
\[
U = S (C \otimes I_P),
\]
where \( I_P \) is the identity operator on \( \mathcal{H}_P \). Repeated application of \( U \) evolves the quantum state over time:
\[
|\psi(t)\rangle = U^t |\psi(0)\rangle.
\]

\subsubsection*{Example: Hadamard Walk from the Origin}

Suppose the initial state of the system is localized at the origin with coin state \( |0\rangle \):
\[
|\psi(0)\rangle = |0\rangle \otimes |0\rangle.
\]
Applying the Hadamard operator and then the shift, the system evolves after one step into a superposition:
\[
|\psi(1)\rangle = \frac{1}{\sqrt{2}} \left( |0\rangle|1\rangle + |1\rangle|-1\rangle \right).
\]
The particle is now in a coherent superposition of being at positions \( +1 \) and \( -1 \), determined by its coin state.

This process continues iteratively. For example, the second and third steps yield:
\begin{align*}
|\psi(2)\rangle &= \frac{1}{2} \left( -|1\rangle|-2\rangle + (|0\rangle + |1\rangle)|0\rangle + |0\rangle|2\rangle \right), \\
|\psi(3)\rangle &= \frac{1}{2\sqrt{2}} \left( |1\rangle|-3\rangle - |0\rangle|-1\rangle + (2|0\rangle + |1\rangle)|1\rangle + |0\rangle|3\rangle \right).
\end{align*}

\subsubsection*{Quantum vs Classical Behavior}

The key difference between quantum and classical random walks lies in the presence of \textit{interference} and \textit{superposition}:
\begin{itemize}
    \item In classical random walks, probabilities are updated step-by-step based on stochastic transitions, leading to a binomial distribution that approximates a Gaussian as time progresses.
    \item In contrast, discrete-time quantum walks generate probability amplitudes that can interfere constructively or destructively depending on the history of the evolution.
\end{itemize}

As a result, the probability distribution of the DTQW is not symmetric or Gaussian, and it spreads much faster than its classical counterpart. Specifically, the standard deviation of a DTQW grows linearly with time \( \sigma(t) \sim t \), while in the classical case it grows as \( \sqrt{t} \).


If a position measurement is performed after every step, the quantum walk collapses into a classical random walk due to decoherence. However, by deferring measurement and allowing the system to evolve unitarily over many steps, quantum correlations between paths persist, yielding a rich interference pattern in the final probability distribution.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Comparison of Models}

From a computational standpoint, both continuous-time and discrete-time quantum walks offer distinct advantages. The continuous-time quantum walk is often considered more natural because it does not require expanding the state space, making it simpler to define and typically easier to analyze. For example, while the exponential speedup demonstrated by continuous-time quantum walks is widely believed to extend to the discrete-time model, the dynamics of the latter are more complex. To date, no rigorous analysis has been provided to confirm this extension.

In contrast, the discrete-time quantum walk is generally more straightforward to implement using quantum circuits. Implementing continuous-time quantum walks, however, often relies on techniques that require the graph's maximum degree to be small. This constraint makes certain algorithms challenging to replicate using continuous-time quantum walks. Therefore, while continuous-time quantum walks excel in simplicity and analytical tractability, discrete-time quantum walks offer greater practicality and ease of implementation in quantum computing applications.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Group Actions}


Group actions provide a framework for understanding how groups interact with sets, formalizing the concept of applying transformations systematically. They capture the symmetries and structure-preserving transformations of objects, making them fundamental in mathematics and its applications. Group actions describe transformations through a set of rules that ensure consistency and compatibility with the underlying group operations. This concept is pivotal in cryptography, where the symmetries and operations of groups underpin many secure systems.

In cryptography, group actions are critical to protocols like Elliptic Curve Cryptography (ECC), which relies on the difficulty of reversing group-based operations to ensure security. Isogeny-based cryptography, a post-quantum cryptographic candidate, uses group actions on elliptic curves to create complex mathematical problems resistant to quantum attacks. Similarly, lattice-based and code-based cryptography use group actions to study transformations in structures that form the basis for secure communication systems. Non-abelian group actions are being explored for their potential to create quantum-resistant algorithms.

In quantum computing, group actions are central to quantum walks, a quantum equivalent of classical random walks. Quantum walks leverage group actions to describe the evolution of quantum states and exploit the symmetries of these states for tasks like search, optimization, and cryptographic protocol design. This makes them valuable in constructing secure quantum algorithms and protocols, particularly in quantum key distribution and graph-based cryptography. Overall, group actions bridge abstract mathematical theory with practical applications in classical and quantum cryptography.


\section*{Definition of Group Action}

Group actions form a bridge between group theory and other mathematical structures, offering a systematic way to study symmetry, transformations, and invariants. Let us delve deeper into their properties, classifications, and applications.

\subsection*{Formal Definition}

A \textbf{group action} of a group \( G \) on a set \( X \) is a map \( \cdot : G \times X \to X \) that satisfies:

\begin{enumerate}
    \item \textbf{Identity Property}:
    \[
    e \cdot x = x \quad \text{for all } x \in X,
    \]
    where \( e \) is the identity element of \( G \).

    \item \textbf{Compatibility (Associativity)}:
    \[
    (gh) \cdot x = g \cdot (h \cdot x) \quad \text{for all } g, h \in G, \, x \in X.
    \]
\end{enumerate}

Alternatively, the group action can be viewed as a homomorphism \( \phi : G \to \text{Sym}(X) \), where \( \text{Sym}(X) \) is the group of all permutations of \( X \).

\subsection*{Types of Group Actions}

\begin{enumerate}
    \item \textbf{Faithful Action}: The action is faithful if \( g \cdot x = x \) for all \( x \in X \) implies \( g = e \). Equivalently, the homomorphism \( \phi \) is injective.
    
    \item \textbf{Transitive Action}: The action is transitive if, for any \( x, y \in X \), there exists \( g \in G \) such that \( g \cdot x = y \). In this case, \( X \) consists of a single orbit.
    
    \item \textbf{Free Action}: The action is free if \( g \cdot x = x \) implies \( g = e \) for all \( x \in X \).
    
    \item \textbf{Regular Action}: The action is both transitive and free, meaning there is exactly one \( g \in G \) for each pair \( (x, y) \) such that \( g \cdot x = y \).
    
    \item \textbf{Effective Action}: The action is effective if the only group element acting as the identity on \( X \) is \( e \).
\end{enumerate}

\subsection*{Key Concepts in Group Actions}

\begin{enumerate}
    \item \textbf{Orbits}:
    For \( x \in X \), the \textbf{orbit} of \( x \) is:
    \[
    \text{Orb}(x) = \{g \cdot x \mid g \in G\}.
    \]
    Orbits partition the set \( X \), and each orbit is a subset where the action appears ``connected.''

    \item \textbf{Stabilizer Subgroup}:
    The \textbf{stabilizer} of \( x \in X \) is:
    \[
    \text{Stab}_G(x) = \{g \in G \mid g \cdot x = x\}.
    \]
    It is a subgroup of \( G \) and describes the symmetries that leave \( x \) unchanged.

    \item \textbf{Orbit-Stabilizer Theorem}:
    This theorem links the size of an orbit and its stabilizer:
    \[
    |G| = |\text{Orb}(x)| \cdot |\text{Stab}_G(x)|.
    \]

    \item \textbf{Fixed Points}:
    A point \( x \in X \) is a \textbf{fixed point} if \( g \cdot x = x \) for all \( g \in G \). The set of fixed points is:
    \[
    \text{Fix}(G) = \{x \in X \mid g \cdot x = x, \, \forall g \in G\}.
    \]

    \item \textbf{Invariant Subsets}:
    A subset \( Y \subseteq X \) is \textbf{invariant} under the action if \( g \cdot y \in Y \) for all \( g \in G \) and \( y \in Y \).
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Groups and Characters}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abelian Groups}

An \textbf{abelian group} (also called a \textbf{commutative group}) is a set \( G \) equipped with a binary operation \( \cdot \) (usually written as addition \( + \) or multiplication \( \cdot \)) that satisfies the following four group axioms, along with an additional \textbf{commutativity} property.

\subsection{Axioms of an Abelian Group}
A set \( G \) with a binary operation \( \cdot \) is an \textbf{abelian group} if the following conditions hold:

\begin{enumerate}
    \item \textbf{Closure}:  
    For all \( a, b \in G \), the operation \( a \cdot b \) produces another element in \( G \):

    \[
    a \cdot b \in G.
    \]

    \item \textbf{Associativity}:  
    For all \( a, b, c \in G \), the operation satisfies:

    \[
    (a \cdot b) \cdot c = a \cdot (b \cdot c).
    \]

    \item \textbf{Identity Element}:  
    There exists an element \( e \in G \) such that for all \( a \in G \):

    \[
    e \cdot a = a \cdot e = a.
    \]

    This element \( e \) is called the \textbf{identity element}.

    \item \textbf{Inverse Element}:  
    For every element \( a \in G \), there exists an element \( a^{-1} \in G \) such that:

    \[
    a \cdot a^{-1} = a^{-1} \cdot a = e.
    \]

    \item \textbf{Commutativity (Abelian Property)}:  
    For all \( a, b \in G \), the operation is \textbf{commutative}:

    \[
    a \cdot b = b \cdot a.
    \]

\end{enumerate}

Since abelian groups satisfy commutativity, they allow more flexible mathematical operations and structure, leading to applications in algebra, number theory, and topology.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Characters of Abelian Groups}
Let \( G \) be an abelian group. A function  

\[
\chi: G \to \mathbb{C}^{\times}
\]

that maps \( G \) to the group of nonzero complex numbers  \(\mathbb{C}^{\times} = \mathbb{C} \setminus \{0\}\), is called a \textbf{character} of \( G \) if it is a \textbf{group homomorphism}. That is, for all \( g_1, g_2 \in G \), the function satisfies:  

\[
\chi(g_1 g_2) = \chi(g_1) \chi(g_2).
\]

\section*{Character Values for Finite Groups}

If \( \chi \) is a character of a finite group (or more generally, a torsion group) \( G \), then each function value \( \chi(g) \) is a root of unity. This follows because, for each \( g \in G \), there exists some integer \( k \in \mathbb{N} \) such that:  

\[
g^k = e.
\]

Applying \( \chi \) to both sides, we obtain:  

\[
\chi(g)^k = \chi(g^k) = \chi(e) = 1.
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Number of Characters in a Finite Abelian Group}

A \textbf{finite abelian group} of order \( n \) has exactly \( n \) distinct characters, denoted by:  

\[
\chi_1, \chi_2, \dots, \chi_n.
\]

The function \( \chi_1 \), defined by:  

\[
\chi_1(g) = 1, \quad \forall g \in G,
\]

is called the \textbf{principal character} of \( G \). The remaining \( n-1 \) characters are referred to as \textbf{non-principal characters}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Character Group}

If \( G \) is an abelian group, the set of characters \( \{\chi_k\} \) forms an abelian group under pointwise multiplication, defined as:  

\[
(\chi_j \chi_k)(g) = \chi_j(g) \chi_k(g), \quad \forall g \in G.
\]

This group is called the \textbf{character group} of \( G \) and is often denoted as $\hat{G}$.  
The \textbf{identity element} of \( \hat{G} \) is the principal character \( \chi_1 \), and the \textbf{inverse} of a character \( \chi_k \) is its reciprocal:  

\[
(\chi_k)^{-1} = \frac{1}{\chi_k}.
\]

If \( G \) is finite of order \( n \), then the character group \( \hat{G} \) is also of order \( n \). In this case, since  

\[
|\chi_k(g)| = 1, \quad \forall g \in G,
\]

the inverse of a character is simply its \textbf{complex conjugate}:

\[
\chi_k^{-1}(g) = \overline{\chi_k(g)}.
\]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Quantum Fourier Transform}

The \textbf{Quantum Fourier Transform (QFT)} is one of the most fundamental unitary transformations in quantum computing. It plays a crucial role in quantum algorithms, including Shor’s algorithm for integer factorization and quantum phase estimation. The QFT is the quantum analog of the classical discrete Fourier transform (DFT) but operates on quantum states, enabling efficient quantum computation of Fourier coefficients.

In this section, we discuss the QFT in the context of abelian groups, with a focus on its implementation over \( \mathbb{Z}_{2^n} \), one of the most commonly used finite groups in quantum algorithms, including quantum walks.

\section{Quantum Fourier Transform Over an Abelian Group}

Let \( G \) be an abelian group. The \textbf{Quantum Fourier Transform} over \( G \) is defined as:

\[
F_G = \frac{1}{\sqrt{|G|}} \sum_{x \in G} \sum_{y \in \hat{G}} \chi(y,x) | y \rangle \langle x |
\]

where:

\begin{itemize}
    \item \( \hat{G} \) is a complete set of characters of \( G \).
    \item \( \chi(y,x) \) denotes the \( y \)th character of \( G \), evaluated at \( x \).
    \item \( |x\rangle \) and \( |y\rangle \) are quantum states corresponding to elements of \( G \) and its dual group \( \hat{G} \).
\end{itemize}

Since \( G \) and \( \hat{G} \) are isomorphic, it is often useful to label the elements of \( \hat{G} \) using elements of \( G \). The unitary nature of the QFT follows from the \textbf{orthogonality of characters}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{QFT Over \( \mathbb{Z}_{2^n} \)}

The QFT over \( G = \mathbb{Z}_{2^n} \) is defined as:

\[
F_{\mathbb{Z}_{2^n}} = \frac{1}{\sqrt{2^n}} \sum_{x,y \in \mathbb{Z}_{2^n}} \omega_{2^n}^{xy} | y \rangle \langle x |
\]

where:

\[
\omega_m = e^{2\pi i / m}
\]

is the \textbf{primitive} \( m \)th root of unity. This transformation maps an input basis state \( |x\rangle \) as follows:

\[
| x \rangle \to \frac{1}{\sqrt{2^n}} \sum_{y \in \mathbb{Z}_{2^n}} \omega_{2^n}^{xy} | y \rangle.
\]

This equation represents a \textbf{linear transformation} where each input state \( |x\rangle \) is mapped to a superposition of all basis states, weighted by phase factors.

\subsection{Binary Representation and QFT Implementation}

To implement this transformation efficiently, it is useful to express \( x \) and \( y \) in binary form:

\[
x = x_{n-1} x_{n-2} \dots x_1 x_0.
\]

The exponent in the Fourier transform formula can then be rewritten using its binary expansion:

\[
\omega_{2^n}^{xy} = e^{2\pi i x \sum_{k=0}^{n-1} y_k 2^k / 2^n}.
\]

Rewriting the transformation explicitly:

\[
| x \rangle \to \frac{1}{\sqrt{2^n}} \sum_{y \in \mathbb{Z}_{2^n}} e^{2\pi i x \sum_{k=0}^{n-1} y_k 2^k / 2^n} | y \rangle.
\]

This can be decomposed into a \textbf{tensor product of single-qubit states}, where each qubit state depends on the least significant bits of \( x \):

\[
\bigotimes_{k=0}^{n-1} | z_k \rangle.
\]

where

\[
| z_k \rangle = \frac{1}{\sqrt{2}} ( | 0 \rangle + e^{2\pi i ( x_0 2^{-n+k} + x_1 2^{-n+k+1} + \dots + x_{n-1} 2^{-1} )} | 1 \rangle ).
\]

This decomposition highlights the \textbf{hierarchical dependence of qubits on the binary digits of \( x \)}, making it possible to implement the QFT using \textbf{Hadamard gates and controlled phase shift gates}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Cayley graphs}

A Cayley graph is a graphical representation of a group based on a chosen set of generators. It is widely used in algebra, combinatorics, and theoretical computer science to study group structures and their applications in network theory, quantum computing, and cryptography.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Definition of Cayley Graphs}

A \textit{Cayley graph} is a graph that encodes the structure of a group with respect to a chosen generating set. Formally, let \( G \) be a group and \( Q \) be a subset of \( G \) that serves as a generating set, meaning every element of \( G \) can be expressed as a finite product of elements from \( Q \). The Cayley graph \( \Gamma(G, Q) \) is defined as follows. The vertex set of the graph consists of the elements of \( G \), where each vertex corresponds to a unique group element. The edge set is constructed by drawing a directed edge from vertex \( g \) to vertex \( gq \) for each \( g \in G \) and \( q \in Q \). If the generating set \( Q \) is symmetric, meaning that whenever \( q \in Q \), its inverse \( q^{-1} \) is also in \( Q \), then the Cayley graph is undirected; otherwise, it is a directed graph.
For example, For the cyclic group \( G = \mathbb{Z}_n = \{0,1,2,\dots, n-1\} \) with the generating set \( Q = \{\pm 1\} \), the Cayley graph forms a cycle graph. In this graph, each vertex \( j \) is connected to \( j+1 \mod n \) and \( j-1 \mod n \), creating a cyclic structure.\\


The adjacency matrix of $\Gamma$ can be expressed as
\[
A = \sum_{a \in G} \lambda_a |\hat{a}\rangle \langle \hat{a}|,
\]
where $|\hat{a}\rangle$ is the quantum Fourier transform of $|a\rangle$. The eigenvalues $\lambda$ are given by
\[
\lambda_a = \sum_{q \in Q} \chi(a, q).
\]
Note that the eigenvectors $|\hat{a}\rangle$ of $A$ depend only on $G$ and not on the set $Q$.

To see this, we have
\[
        A\ket{\hat{a}} = A.\frac{1}{\sqrt{|G|}}\sum_{y \in G}\chi(a,y)\ket{y} = \frac{1}{\sqrt{|G|}}\sum_{y \in G}\chi(a,y).A\ket{y}
        \]
        \[
        = \frac{1}{\sqrt{|G|}}\sum_{y \in G}\chi(a,y).\sum_{q \in Q}\ket{qy}
        \]
        Consider $\beta = qy$. Then:
        \[
         = \frac{1}{\sqrt{|G|}}\sum_{q \in Q}\chi(a,q)\sum_{\beta}\chi(a,\beta)\ket{\beta} = \sum_{q \in Q}\chi(a,q) . \ket{\hat{a}}
        \]
        \[
         = \lambda_a\ket{\hat{a}}
        \]




\section*{Quantum walks on Cayley graphs}
Quantum walks on Cayley graphs play a crucial role in quantum computing, quantum search algorithms, and mathematical physics due to their deep connection with group theory and symmetry. The structured nature of Cayley graphs, derived from group elements and generators, ensures uniform exploration of the graph, leading to faster propagation compared to classical random walks. This property is particularly valuable in quantum algorithms, where quantum walks on Cayley graphs have been used to achieve exponential speedups in search and optimization problems. Additionally, their spectral properties, determined by the adjacency matrix and Fourier analysis on groups, provide insights into mixing times, state localization, and quantum transport phenomena. These advantages make Cayley graphs an essential framework for designing scalable and efficient quantum algorithms, offering a powerful bridge between algebraic structures and quantum mechanics.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Discrete-Time Quantum Walk on Cayley Graphs}

A discrete-time quantum walk on a Cayley graph requires a coin operator to maintain unitary evolution.

\subsection*{State Space}
The Hilbert space of the quantum walk is:
\[
\mathcal{H} = \mathcal{H}_G \otimes \mathcal{H}_C,
\]
where:
\begin{itemize}
    \item \( \mathcal{H}_G \) is the space spanned by group elements (vertices).
    \item \( \mathcal{H}_C \) is the coin space, which determines movement directions.
\end{itemize}

Each state is represented as:
\[
|\psi\rangle = \sum_{g \in G} \sum_{q \in Q} \alpha_{g,q} |g\rangle \otimes |q\rangle,
\]
where \( |g\rangle \) is the vertex state and \( |q\rangle \) represents the coin state.

\subsection*{Evolution Operators}
\textbf{Coin Flip Operator (\( C \))}: This unitary operator acts on the coin space to create a superposition of movement directions. A common choice is the Grover or Hadamard operator.

\textbf{Shift Operator (\( S \))}: Moves the walker according to the group structure:
\[
S |g\rangle \otimes |s\rangle = |gs\rangle \otimes |s\rangle.
\]
This means that if the walker is at vertex \( g \) with a coin state \( s \), it moves to \( gs \).

\textbf{Full Step Evolution}:
\[
U = S (C \otimes I),
\]
where \( U \) is the total unitary evolution per step.

The probability of finding the walker at a particular vertex \( g \) after \( t \) steps is given by:
\[
P(g, t) = \sum_{s \in S} |\langle g, s | \psi(t) \rangle |^2.
\]


\section*{Continuous-Time Quantum Walk on Cayley Graphs}

A continuous-time quantum walk on a Cayley graph follows a different evolution, governed by the Hamiltonian.

\subsection*{Hamiltonian and Evolution}
The evolution of the quantum walk is determined by the Schrödinger equation:
\[
i \frac{d}{dt} |\psi(t)\rangle = H |\psi(t)\rangle.
\]
Here, the Hamiltonian \( H \) is usually chosen as:
\[
H = A(\Gamma(G,S)),
\]
where \( A \) is the adjacency matrix of the Cayley graph:

\[
A_{g,h} =
\begin{cases}
1, & \text{if } h = gs \text{ for some } s \in S, \\
0, & \text{otherwise}.
\end{cases}
\]
 Alternatively, the Laplacian \( L \) can be used:
\[
H = L = D - A,
\]
where \( D \) is the degree matrix:

\[
D_{ij} =
\begin{cases}
\deg(v_i), & \text{if } i = j, \\
0, & \text{otherwise}.
\end{cases}
\]

Here, \( \deg(v_i) \) is the degree of vertex \( v_i \), which is the number of edges connected to \( v_i \).


The solution to the quantum walk is given by:
\[
|\psi(t)\rangle = e^{-i H t} |\psi(0)\rangle.
\]
This means the probability amplitude at a vertex \( g \) spreads over time according to the unitary evolution operator \( e^{-i H t} \).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Example: Cyclic Group \( \mathbb{Z}_n \)}

Consider the Cayley graph of \( \mathbb{Z}_n \) with generator set \( S = \{\pm 1\} \), which forms a cycle graph. The adjacency matrix is:
\[
A_{jk} =
\begin{cases}
1, & \text{if } k = j \pm 1 \mod n, \\
0, & \text{otherwise}.
\end{cases}
\]

Its eigenvalues are:
\[
\lambda_k = 2\cos\left(\frac{2\pi k}{n}\right),
\]
with eigenvectors given by the discrete Fourier transform (DFT) basis:
\[
\psi_k(j) = e^{\frac{2\pi i k j}{n}}.
\]

This result generalizes to other Abelian groups, where the eigenvectors are given by the Fourier basis of the group.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Simulating continuous-time walks}
Childs~\cite{childs2010relationship} and Berry, Childs, and Kothari~\cite{berry2015hamiltonian} showed that continuous-time quantum walks can be simulated using discrete-time quantum walks. Since our approach relies on their methods, we begin by outlining the relevant notation and framework.

Let \( H \) be a Hamiltonian of dimension \( N = 2^n \), and define \( \opnorm{H}_{\mathrm{max}} = \max_{i, j} \abs{H_{ij}} \). To facilitate the simulation, we expand the Hilbert space from \( \C^N \) to \( \C^{2N} \otimes \C^{2N} \) by appending an ancilla qubit initialized to \( \ket{0} \) and duplicating the resulting space.

To define the discrete-time walk operator, we first construct an orthonormal set of states:
\begin{align}
    \ket{\phi_{j0}} & := \frac{1}{\sqrt{d}} \sum_{\ell \in F_j} \ket{\ell} \left( \sqrt{\frac{H_{j\ell}^*}{K}} \ket{0} + \sqrt{1 - \frac{\abs{H_{j\ell}^*}}{K}} \ket{1} \right), \label{eq:walk-sim} \\
    \ket{\phi_{j1}} & := \ket{0} \ket{1}, \nonumber
\end{align}
where \( F_j \) denotes the set of nonzero entries in column \( j \) of \( H \), and \( K \ge \opnorm{H}_{\mathrm{max}} \) is a fixed constant.

Based on these states, we define the isometry \( T : \C^{2N} \to \C^{2N} \otimes \C^{2N} \) as follows:
\begin{equation}
    \label{eq:walk-isom}
    T := \sum_{j = 0}^{N - 1} \sum_{b \in \{0, 1\}} (\ket{j}\bra{j} \otimes \ket{b}\bra{b}) \otimes \ket{\phi_{jb}}.
\end{equation}

The discrete-time quantum walk operator is then defined as
\[
W = iS(2TT^* - \mathds{1}),
\]
where \( S \) is the swap operator acting as
\[
S \ket{j_1} \ket{b_1} \ket{j_2} \ket{b_2} = \ket{j_2} \ket{b_2} \ket{j_1} \ket{b_1},
\]
for all \( 0 \le j_1, j_2 < N \) and \( b_1, b_2 \in \{0, 1\} \).

To efficiently simulate the continuous-time evolution \( e^{-iHt} \), it suffices to implement the isometry \( T \), its adjoint \( T^* \), and the walk operator \( W \) efficiently. Assuming black-box (oracle) access to the entries of \( H \), the following result holds:

\begin{theorem}[{\cite[Theorem 1]{berry2015hamiltonian}}]
\label{thm:sparse-sim}
Let \( H \) be a \( d \)-sparse Hamiltonian acting on \( n \) qubits. Then the unitary \( e^{-iHt} \) can be approximated to within error \( \epsilon \) using
\[
O\left( \tau \frac{\log(\tau / \epsilon)}{\log\log(\tau / \epsilon)} \right)
\]
queries to \( H \), and
\[
O\left( \tau \left[ n + \log^{5 / 2}(\tau / \epsilon) \right] \frac{\log(\tau / \epsilon)}{\log\log(\tau / \epsilon)} \right)
\]
additional elementary gates, where \( \tau = d \cdot \opnorm{H}_{\mathrm{max}} \cdot t \).
\end{theorem}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Quantum walks from Group Actions}


Let \( G \) be an abelian group, and let \( Q = \{q_1, q_2, \dots, q_k\} \subset G \) be a symmetric generating set, meaning that \( q \in Q \) if and only if \( -q \in Q \). The Cayley graph associated with \( G \) and \( Q \) is defined as \( \Gamma = (V, E) \), where the vertex set is \( V = G \), and the edge set consists of all pairs \( (a, b) \in G \times G \) such that \( b = q + a \) for some \( q \in Q \).

The adjacency matrix \( A \) of \( \Gamma \) admits a spectral decomposition:
\[
A = \sum_{a \in G} \lambda_a \ket{\hat{a}} \bra{\hat{a}},
\]
where \( \ket{\hat{a}} \) denotes the quantum Fourier transform of \( \ket{a} \), and the eigenvalues \( \lambda_a \) are given by
\[
\lambda_a = \sum_{q \in Q} \chi(a, q).
\]
Importantly, the eigenvectors \( \ket{\hat{a}} \) depend solely on the group \( G \), not on the choice of the generating set \( Q \).

Cayley graphs can also be generalized through group actions. Let \( (G, X, *) \) be a regular group action with a fixed element \( x \in X \), and let \( Q = \{q_1, q_2, \dots, q_k\} \subset G \) be a subset as before. Define the Cayley graph \( \Gamma = (X, E) \), where the vertex set is \( X \), and the edge set consists of all pairs \( (x, y) \in X \times X \) such that \( y = q * x \) for some \( q \in Q \).

The adjacency matrix of this graph can be written as:
\[
A = \sum_{h \in G} \lambda_h \ket{G^{(h)} * x} \bra{G^{(h)} * x},
\]
where
\[
\lambda_h = \sum_{q \in Q} \chi(h, q), \quad \text{and} \quad \ket{G^{(h)} * x} = \frac{1}{\sqrt{|G|}} \sum_{g \in G} \chi(g, h) \ket{g * x}.
\]

As in the previous case, the eigenvectors \( \ket{G^{(h)} * x} \) are determined solely by the structure of the group \( G \). This construction generalizes the standard Cayley graph: setting \( X = G \) and the group action \( * \) as group multiplication recovers the original definition.


To see this, we have:

\[
    A\ket{G^{(h)}*x} = \frac{1}{\sqrt{|G|}}.\sum_{g \in G}\chi(g,h) A.\ket{g*x}
    \]

    \[
    = A\ket{G^{(h)}*x} = \frac{1}{\sqrt{|G|}}.\sum_{g \in G}\chi(g,h)\sum_{q \in Q}\ket{q*(g*x)}
    \]
    Consider $\beta = qg$. Then:
    \[
    = = \frac{1}{\sqrt{|G|}}\sum_{q \in Q}\sum_{\beta \in G}\chi(\beta,h)\chi(q,h)\ket{\beta * x}
    \]

    \[
    = \sum_{q \in Q}\chi(q,h).\ket{G^{(h)}*x} = \lambda_h \ket{G^{(h)}*x}
    \]

    Since the group action \( (G, X, *) \) is regular, the two Cayley graph constructions are isomorphic. In the first construction, the vertex set is \( G \), and the adjacency matrix is indexed by elements of \( G \). In the second construction, the vertex set is \( X \), with the adjacency matrix indexed by elements of \( X \). The isomorphism between these graphs is given by the bijection
\[
\setlength{\arraycolsep}{1mm}
\begin{array}{rcll}
\phi: & G & \longrightarrow & X \\
      & g & \longmapsto     & g * x,
\end{array}
\]

which maps each group element \( g \in G \) to the corresponding point in its orbit under the action.


    % Assuming the group action is a cryptographic group action, the isomorphism $\phi$ is a one-way function: given $g \in G$, it is easy to compute $g * x$, whereas given $(x, g * x)$, it is hard to compute $g$. Therefore, although these graphs are mathematically the same, computational problems based on them require fundamentally different techniques. A notable example is the implementation of quantum walks on these graphs.\footnote{Implementations of continuous-time quantum walks in the context of cryptographic group actions have previously appeared in \cite{booher2024failing, doliskani2023sample}, in the setting of supersingular isogeny graphs. These walks can be interpreted as group-action walks.} From this point onward, assume $Q$ is a small set, i.e., $\abs{Q} = \poly(\log \abs{G})$. In the first graph, we can efficiently implement the walks $e^{-iAt}$ even for values of $t$ that are exponentially large in $\log \abs{G}$. This follows from the fact that
    % \begin{equation}
    %     \label{eq:adjmat-fb}
    %     e^{-iAt} = \qft_G \sum_{a \in G} e^{-i\lambda_a t} \ket{a} \bra{a} \qft_G^*.
    % \end{equation}
    % The quantum Fourier transform $\qft_G$ and its inverse can be applied in $\poly(\log \abs{G})$ operations. The diagonal unitary in the middle, which is a phase computation $\ket{a} \mapsto e^{-i\lambda_a t} \ket{a}$, is also efficient because $\lambda_a$ can be computed classically to arbitrary precision in $\poly(\log \abs{G})$ time.
    
    % The situation for group actions is less straightforward. While the states $\ket{G^{(h)} * x}$ are analogous to the states $\ket{\hat{h}}$, the involvement of the action $*$ in the former introduces computational challenges. Specifically, it becomes hard to apply transformations beyond the action $\ket{y} \mapsto \ket{a * y}$ for $a \in G$. Consequently, no decomposition analogous to \eqref{eq:adjmat-fb} exists in the context of group actions. Instead, we are left with the spectral expression
    % \[ e^{-iAt} = \sum_{h \in G} e^{-i\lambda_h t} \ket{G^{(h)} * x} \bra{G^{(h)} * x}. \]
    % Despite this limitation, the sparsity and structure of the matrix $A$ allow us to demonstrate in the next section that for $t = \poly(\log \abs{G})$, the walk $e^{-iAt}$ can still be efficiently approximated to polynomial accuracy.   


    When the group action \( (G, X, *) \) is assumed to be cryptographic, the isomorphism \( \phi \) becomes a one-way function: given \( g \in G \), it is efficient to compute \( g * x \), but given the pair \( (x, g * x) \), it is computationally hard to recover \( g \). As a result, while the two Cayley graphs are mathematically isomorphic, computational tasks associated with them may require fundamentally different approaches. A particularly illustrative example is the implementation of quantum walks on these graphs.\footnote{Continuous-time quantum walks have been explored in the context of cryptographic group actions in~\cite{booher2024failing, doliskani2023sample}, specifically in supersingular isogeny graphs. These walks can be viewed as group-action quantum walks.}

    From this point forward, we assume the generating set \( Q \) is small, i.e., \( \abs{Q} = \poly(\log \abs{G}) \). In the first construction (where \( X = G \)), the walk \( e^{-iAt} \) can be efficiently implemented even for values of \( t \) that are exponentially large in \( \log \abs{G} \). This is a consequence of the identity:
    \begin{equation}
        \label{eq:adjmat-fb}
        e^{-iAt} = \qft_G \left( \sum_{a \in G} e^{-i\lambda_a t} \ket{a} \bra{a} \right) \qft_G^*,
    \end{equation}
    where \( \qft_G \) and its inverse can be implemented in \( \poly(\log \abs{G}) \) time. Moreover, the diagonal phase unitary \( \ket{a} \mapsto e^{-i\lambda_a t} \ket{a} \) is also efficient to implement, since the eigenvalues \( \lambda_a \) can be computed classically to arbitrary precision in \( \poly(\log \abs{G}) \) time.

    In contrast, the group-action setting presents greater computational difficulty. Although the states \( \ket{G^{(h)} * x} \) play a role analogous to the Fourier basis states \( \ket{\hat{h}} \), the presence of the action \( * \) makes the situation more subtle. In particular, implementing general transformations over these states is difficult; we are typically limited to operations of the form \( \ket{y} \mapsto \ket{a * y} \) for \( a \in G \). As a result, no efficient decomposition similar to~\eqref{eq:adjmat-fb} is known in the group-action setting. Instead, the best we can express is the spectral decomposition:
    \[
    e^{-iAt} = \sum_{h \in G} e^{-i\lambda_h t} \ket{G^{(h)} * x} \bra{G^{(h)} * x}.
    \]

    Despite this limitation, the adjacency matrix \( A \) retains a high degree of sparsity and algebraic structure. In the next section, we will show that for \( t = \poly(\log \abs{G}) \), the walk \( e^{-iAt} \) can still be efficiently approximated to polynomial accuracy.

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    
\paragraph{Simulating group action quantum walks.}
Assume \( t = \poly(\log \abs{G}) \). We show that the continuous-time walk \( W = e^{-iAt} \) can be efficiently simulated using the discrete-time quantum walk framework developed in~\cite{childs2010relationship, berry2015hamiltonian}. Recall the isometry \( T \) defined in Equation~\eqref{eq:walk-isom}, where the states \( \ket{\phi_b} \) are as given in Equation~\eqref{eq:walk-sim}. To carry out the simulation, it suffices to show that the isometry \( T \), its adjoint \( T^* \), and the discrete-time walk operator
\[
W = iS(2TT^* - \mathds{1})
\]
can all be efficiently implemented in the group-action setting.

Let \( \Gamma = (X, E) \) be the Cayley graph associated with the group action \( (G, X, *) \), and let \( A \) denote its adjacency matrix. The Hamiltonian \( H \) of interest is simply \( A \), indexed by elements of \( X \). In this context, the isometry \( T \) takes the form:
\begin{align*}
T
& := \sum_{y \in X} \sum_{b \in \{0, 1\}} (\ket{y}\bra{y} \otimes \ket{b}\bra{b}) \otimes \ket{\phi_{yb}} \\
& = \sum_{y \in X} \sum_{b \in \{0, 1\}} \ket{y} \ket{b} \ket{\phi_{yb}} \bra{y} \bra{b}.
\end{align*}


Because of the structure of $\Gamma$, the states \eqref{eq:walk-sim} simplify as follows. First, since the set $Q$ is symmetric, the graph $\Gamma$ is undirected and the adjacency matrix $A$ is symmetric with non-negative entries; the nonzero entries of $A$ are all equal to $1$. Therefore, we can set $K = \opnorm{A}_{\mathrm{max}} = 1$. As a result, for $y \in X$, the state $\ket{\phi_{y0}}$ becomes
\[ \ket{\phi_{y0}} = \frac{1}{\sqrt{\abs{Q}}} \sum_{q \in Q} \ket{q * y} \ket{0}. \]
We now describe how to implement the isometry \( T \) by constructing efficient unitaries \( U_0 \) and \( U_1 \), where each \( U_b \) acts as
\[
U_b : \ket{0} \ket{y, b} \ket{0, 0} \mapsto \ket{0} \ket{y, b} \ket{\phi_{yb}}, \quad b \in \{0, 1\},
\]
with the first register serving as an ancilla.

The unitary \( U_1 \) is straightforward to implement, since \( \ket{\phi_{y1}} = \ket{0} \ket{1} \) is independent of \( y \). We now focus on the construction of \( U_0 \).

Because \( Q \subset G \) is a small set (i.e., \( \abs{Q} = \poly(\log \abs{G}) \)), we can construct an efficient unitary \( V_Q : \C^Q \to \C^Q \) such that
\[
V_Q \ket{0} = \frac{1}{\sqrt{\abs{Q}}} \sum_{q \in Q} \ket{q}.
\]
Applying \( V_Q \otimes \mathds{1} \) to the state \( \ket{0} \ket{y, 0} \ket{0, 0} \) produces:
\[
\frac{1}{\sqrt{\abs{Q}}} \sum_{q \in Q} \ket{q} \ket{y, 0} \ket{0, 0}.
\]

Next, we apply the unitary \( V_1 \), defined by:
\[
V_1 : \ket{q} \ket{y, 0} \ket{0, 0} \mapsto \ket{q} \ket{y, 0} \ket{q * y, 0}.
\]

Following this, we uncompute the first register to recover \( \ket{0} \ket{y, 0} \ket{\phi_{y0}} \). This is achieved by applying the unitary \( V_2 \), defined as:
\[
V_2 : \ket{q} \ket{y, 0} \ket{q * y, 0} \mapsto \ket{0} \ket{y, 0} \ket{q * y, 0}.
\]
Since \( Q \) is small, we can efficiently determine \( q \) from the pair \( (y, q * y) \) by exhaustively checking each \( q \in Q \). Thus, \( V_2 \) (and therefore \( U_0 \)) can be implemented efficiently.


To implement \( U_0^* : \ket{0} \ket{y, 0} \ket{\phi_{y0}} \mapsto \ket{0} \ket{y, 0} \ket{0, 0} \), we sequentially apply \( V_2^* \), followed by \( V_1^* \), and finally \( V_Q^* \otimes \mathds{1} \). Since each of these unitaries can be implemented efficiently, it follows that \( U_0^* \) is also efficient.

We now construct the isometry \( T \) using a conditional unitary \( U_T \), which applies either \( U_0 \) or \( U_1 \) depending on the value of the qubit \( b \). That is,
\[
U_T = \text{Controlled-}U_b \quad \text{with control on } b \in \{0,1\}.
\]

Next, we demonstrate that the walk unitary
\[
W = iS(2TT^* - \mathds{1})
\]
can be applied efficiently. This reduces to implementing the reflection \( 2TT^* - \mathds{1} \), which we analyze as follows:
\begin{align*}
2\ket{0}\bra{0} \otimes TT^* - \mathds{1}
&= 2\ket{0}\bra{0} \otimes \sum_{y \in X} \sum_{b \in \{0,1\}} \ket{y,b} \ket{\phi_{yb}} \bra{y,b} \bra{\phi_{yb}} - \mathds{1} \\
&= 2\sum_{y \in X} \sum_{b \in \{0,1\}} \ket{0} \ket{y,b} \ket{\phi_{yb}} \bra{0} \bra{y,b} \bra{\phi_{yb}} - \mathds{1} \\
&= U_T \left( 2 \sum_{y \in X} \sum_{b \in \{0,1\}} \ket{0} \ket{y,b} \ket{0,0} \bra{0} \bra{y,b} \bra{0,0} - \mathds{1} \right) U_T^* \\
&= U_T \left( 2\ket{0}\bra{0} \otimes \mathds{1}_{X,b} \otimes \ket{0,0}\bra{0,0} - \mathds{1} \right) U_T^*.
\end{align*}

Since \( U_T \), \( U_T^* \), and the operator \( 2\ket{0}\bra{0} \otimes \mathds{1}_{X,b} \otimes \ket{0,0}\bra{0,0} - \mathds{1} \) can all be implemented efficiently, it follows that the reflection \( 2\ket{0}\bra{0} \otimes TT^* - \mathds{1} \) is also efficient.

Finally, for any input state \( \ket{\psi} \), the reflection acts as:
\[
\left(2\ket{0}\bra{0} \otimes TT^* - \mathds{1} \right) \ket{0} \ket{\psi} = \ket{0} \left(2TT^* - \mathds{1} \right) \ket{\psi},
\]
confirming that the full walk operator \( W \) can be implemented efficiently in the group-action setting.










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Applicaions}
\section{Quantum Money}
\section*{Introduction to Quantum Money}
Quantum money is a revolutionary concept in cryptography that uses quantum mechanics to create a form of currency that is provably secure against forgery. Originally introduced by physicist Stephen Wiesner in the 1970s, quantum money represents one of the earliest proposed applications of quantum information science. By encoding information into quantum states, quantum money exploits the fundamental principles of quantum mechanics to provide security features unattainable by classical systems.

% \section*{How Quantum Money Works}
% At its core, quantum money relies on two key principles of quantum mechanics: the \textit{no-cloning theorem} and the \textit{observer effect}.

% \subsection*{Encoding Information in Quantum States}
% \begin{itemize}
%     \item Each quantum bill contains a unique quantum state, such as a set of qubits encoded in superposition.
%     \item These states are generated and stored by the issuing authority (e.g., a central bank) using a secret algorithm.
% \end{itemize}

% \subsection*{Verification Process}
% \begin{itemize}
%     \item The issuing authority also generates a verification protocol, allowing a legitimate quantum bill to be authenticated.
%     \item When a user presents a quantum bill for verification, the authority measures the encoded quantum states using the pre-determined protocol.
%     \item If the measured states align with the expected values, the bill is deemed valid.
% \end{itemize}

% \subsection*{Unforgeability}
% \begin{itemize}
%     \item Due to the \textit{no-cloning theorem}, it is impossible to copy an unknown quantum state without altering it.
%     \item Any attempt to measure or duplicate the quantum state results in a disturbance detectable during verification.
% \end{itemize}

% \section*{Key Principles Underpinning Quantum Money}
% \begin{enumerate}
%     \item \textbf{No-Cloning Theorem:} The no-cloning theorem states that an unknown quantum state cannot be perfectly copied. This makes quantum money inherently secure, as counterfeiters cannot reproduce the quantum states encoded in legitimate currency.
%     \item \textbf{Measurement Disturbance:} Observing or measuring a quantum state generally alters it. This ensures that any unauthorized attempt to inspect the quantum money will render it invalid, as the encoded states will no longer match their original form.
%     \item \textbf{Randomness and Superposition:} Quantum money utilizes superposition to encode information. For example, a single qubit in superposition may represent both $0$ and $1$ simultaneously until measured. The randomness of these states makes predicting or reproducing them without knowledge of the original encoding impossible.
%     \item \textbf{Entanglement (Optional Feature):} Some implementations of quantum money involve quantum entanglement, where pairs of quantum states are interconnected. Changes to one entangled state directly affect its pair, adding another layer of security against forgery.
% \end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Benefits of Quantum Money}
\begin{itemize}
    \item \textbf{Unforgeable:} Classical currency, both physical and digital, can be counterfeited with enough effort and resources. Quantum money, however, is fundamentally unforgeable due to the laws of quantum physics.
    \item \textbf{Decentralized Verification:} In some theoretical models, quantum money can be verified without contacting the issuing authority, enabling decentralized systems for authentication.
    \item \textbf{Enhanced Privacy:} The unique encoding of each quantum bill could allow for privacy-preserving transactions, as the details of the transaction need not be linked to the bill's verification.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quantum Money From Group Actions}
A public-key quantum money scheme consists of two QPT algorithms: 
\begin{itemize}
\item $\gen(1^\lambda)$: This algorithm takes a security parameter $\lambda$ as input and outputs a pair $(s, \rho_s)$, where $s$ is a binary string called the serial number, and $\rho_s$ is a quantum state called the banknote. The pair $(s, \rho_s)$, or simply $\rho_s$, is sometimes denoted by $\$$.
\item $\ver(s, \rho_s)$ This algorithm takes a serial number and an alleged banknote as input and outputs either $1$ (accept) or $0$ (reject).
\end{itemize}

The quantum money scheme is said to be \textit{correct} if genuine banknotes generated by $\gen$ are accepted by $\ver$ with high probability. More formally:
\[ \Pr[\ver(s, \rho_s) = 1 : (s, \rho_s) \gets \gen(1^\lambda)] \ge 1 - \negl(\lambda). \]
where the probability is taken over the randomness of $\gen$ and $\ver$. The scheme $(\gen, \ver)$ is said to be secure if, given a genuine bill $(s, \rho_s)$, no QPT algorithm $\mathcal{A}$ can produce two (possibly entangled) bills $(s, \rho_1)$ and $(s, \rho_2)$ that are both accepted by $\ver$ with non-negligible probability. More formally:
\[ \Pr\left[ \ver(s, \rho_1) = \ver(s, \rho_2) = 1 : \substack{(s, \rho_s) \gets \gen(1^\lambda) \\ (\rho_1, \rho_2) \gets \mathcal{A}(s, \rho_s)} \right] \le \negl(\lambda). \]

We now briefly outline the quantum money construction from \cite{zhandry2024quantum}, which is based on abelian group actions. We will the $\comph$ algorithm:
\paragraph{The $\comph$ Algorithm.}
Given access to the state $\ket{G^{(h)} * x}$, one can efficiently recover the value of $h$ via a quantum algorithm. In particular, there exists a unitary transformation that maps
\[
\ket{G^{(h)} * x} \ket{0} \mapsto \ket{G^{(h)} * x} \ket{h},
\]
leveraging the technique of \textit{phase kickback}. The process proceeds as follows:

Begin with the state $\ket{G^{(h)} * x} \ket{0}$ and apply the quantum Fourier transform (QFT) to the second register. Then apply the unitary operator
\[
\sum_{k \in G} U_k \otimes \ket{k}\bra{k}
\]
to both registers. This operation encodes the character information into the phase, resulting in the state
\[
\frac{1}{\sqrt{\abs{G}}} \sum_{k \in G} \ket{G^{(h)} * x} \chi(-k, h) \ket{k}.
\]
Finally, applying the inverse QFT to the second register disentangles the phase and reveals $h$, yielding the final state $\ket{G^{(h)} * x} \ket{h}$.

\vspace{0.5cm}
Let $\{(G_\lambda, X_\lambda, *)\}_{\lambda \in J}$, where $J \subset \N$, be a collection of cryptographic group actions for abelian groups $G_\lambda$, and let $x_\lambda \in X_\lambda$ be a fixed element. The $\gen$ and $\ver$ algorithms are as follows:
\begin{itemize}
\item $\gen(1^\lambda)$. Begin with the state $\ket{0}\ket{x_\lambda}$, and apply the quantum Fourier transform over $G_\lambda$ to the first register producing the superposition
    \[ \frac{1}{\sqrt{\abs{G_\lambda}}} \sum_{g \in G_\lambda} \ket{g}\ket{x_\lambda}. \]
    Next, apply the unitary transformation $\ket{h}\ket{y} \mapsto \ket{h}\ket{h * y}$ to this state, followed by the quantum Fourier transform on the first register. This results in
    \[ \frac{1}{\abs{G_\lambda}} \sum_{h \in G_\lambda} \sum_{g \in G_\lambda} \chi(g, h) \ket{h}\ket{g * x_\lambda} = \frac{1}{\sqrt{\abs{G_\lambda}}} \sum_{h \in G_\lambda} \ket{h} \ket{G^{(h)} * x_\lambda} \]
    where,
    \[
    \ket{G^{(h)}*x_\lambda} = \frac{1}{\sqrt{|G_\lambda|}}\sum_{g \in G_\lambda}\chi(g,h)\ket{g*x_\lambda}
    \]
    . Measure the first register to obtain a random $h \in G_\lambda$, collapsing the state to $\ket{G^{(h)} * x_\lambda}$. Return the pair $(h, \ket{G^{(h)} * x_\lambda})$.

\item $\ver(h, \ket{\psi})$. First, check whether $\ket{\psi}$ has support in $X_\lambda$. If not, return $0$. Then, apply $\comph$ to the state $\ket{\psi}\ket{0}$, and measure the second register to obtain some $h' \in G_\lambda$. If $h' = h$, return $1$; otherwise return $0$.
\end{itemize}

From this point forward, to simplify the notation, we make the security parameter $\lambda$ implicit, and use $G$ for $G_\lambda$, $X$ for $X_\lambda$, and so on. 




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Quantum Hartley Transform (QHT)}

The \textbf{Quantum Hartley Transform (QHT)} is a linear unitary transform that operates on quantum states. It transforms the basis states \( |x\rangle \) as follows:
\[
|x\rangle \xrightarrow{\text{QHT}} \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \text{cas}\left(\frac{2\pi x k}{N}\right) |k\rangle
\]
where:
\begin{itemize}
    \item \( x \) and \( k \) are integers in \( \{0, 1, \dots, N-1\} \),
    \item \( \text{cas}(x) = \cos(x) + \sin(x) \),
    \item \( N \) is the dimension of the transform, typically \( 2^n \) for \( n \)-qubit systems.
\end{itemize}

For a quantum state \( |\psi\rangle \) in an \( N \)-dimensional Hilbert space, represented as:
\[
|\psi\rangle = \sum_{x=0}^{N-1} \psi_x |x\rangle,
\]
the QHT transforms the state into:
\[
|\psi'\rangle = \text{QHT} |\psi\rangle = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \left( \sum_{x=0}^{N-1} \psi_x \, \text{cas}\left(\frac{2\pi x k}{N}\right) \right) |k\rangle.
\]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Properties of the QHT}
\begin{enumerate}
    \item \textbf{Unitary Transformation}: The QHT matrix \( U_{\text{QHT}} \) is unitary:
    \[
    U_{\text{QHT}} U_{\text{QHT}}^\dagger = I,
    \]
    preserving quantum state normalization.
    \item \textbf{Symmetry}: The QHT is symmetric because \( \text{cas}(x) = \text{cas}(-x) \).
    \item \textbf{Efficient Implementation}: Like the Quantum Fourier Transform (QFT), the QHT can be implemented with \( O(\log^2 N) \) gates for \( N = 2^n \).
\end{enumerate}

% \subsection*{Comparison with the Quantum Fourier Transform (QFT)}
% The QFT and QHT differ in their transformation kernels:
% \begin{itemize}
%     \item \textbf{QFT}:
%     \[
%     |x\rangle \xrightarrow{\text{QFT}} \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{2\pi i x k / N} |k\rangle.
%     \]
%     \item \textbf{QHT}:
%     \[
%     |x\rangle \xrightarrow{\text{QHT}} \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \left[\cos\left(\frac{2\pi x k}{N}\right) + \sin\left(\frac{2\pi x k}{N}\right)\right] |k\rangle.
%     \]
% \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Efficient implementation of Heartly transform}

% Our algorithm for the quantum Hartley transform, $\qht_N$, is inspired by the recursive algorithm for computing the quantum Fourier transform ($\qft_N$). Let us briefly explain how the algorithm for $\qft_N$ works. For simplicity, we assume $N = 2^n$, so that elements of $\Z_N$ are represented using exactly $n$ qubits. The generalization to arbitrary $N$ can be achieved by following the same recursive approach. Given $a \in \Z_N$, the expression for $\qft_N$ is written as follows:

Our algorithm for the quantum Hartley transform, \( \qht_N \), is modeled after the recursive structure of the quantum Fourier transform algorithm \( \qft_N \). To motivate this, we begin by reviewing the standard approach for computing \( \qft_N \). For clarity, we assume \( N = 2^n \), allowing each element of \( \Z_N \) to be represented using exactly \( n \) qubits. The same recursive framework can be extended to handle general values of \( N \). For any \( a \in \Z_N \), the quantum Fourier transform is defined as:


\begin{align*}
    \qft_N\ket{a}
    & = \frac{1}{\sqrt{N}} \sum_{y = 0}^{N - 1} \omega_N^{ay}\ket{y} \\
    & = \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \omega_N^{ay} \ket{y} + (-1)^a \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \omega_N^{ay} \ket{y + N/2} \\
    & = \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \omega_N^{ay} \frac{1}{\sqrt{2}} (\ket{0} + (-1)^a \ket{1}) \ket{y}, \numberthis\label{eq:qft_alt}
\end{align*}


In the final expression, we have isolated the first qubit for clarity. Let \( \ket{a} = \ket{t}\ket{b} \), where \( b \) denotes the least significant bit of \( a \), implying that \( a = 2t + b \) for some \( t \in \Z_{N / 2} \). Applying \( \qft_{N / 2} \) to the first register yields the state:

\[ \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \omega_N^{2ty} \ket{y} \ket{b}. \]
Next, we apply the phase unitary \( P(y, b) \), defined by \( \ket{y} \ket{b} \mapsto \omega_N^{by} \ket{y} \ket{b} \), followed by a Hadamard transform on the final qubit. This results in the state given in Equation~\eqref{eq:qft_alt}.


We now describe our algorithm for efficiently computing the quantum Hartley transform \( \qht_N \). The key idea is to leverage the recursive structure of \( \qht_N \), analogous to the strategy used for \( \qft_N \). To facilitate this, we begin by rewriting the summation in Equation~\eqref{eq:qht-N} to expose its recursive form. Our approach is as follows:
\begin{equation}
    \label{eq:cas-expand}
	\frac{1}{\sqrt{N}} \sum_{y = 0}^{N - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \ket{y}
    = \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \ket{y} + \frac{1}{\sqrt{N}} \sum_{y = N / 2}^{N - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \ket{y}.
\end{equation}



The second summation on the right-hand side can be expressed as:
\begin{align*}
	\sum_{y = N / 2}^{N - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \ket{y}
    & = \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi a y}{N} + \pi a \Big) \ket{y + N/2} \\
    & = (-1)^a \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \ket{y + N/2},
\end{align*}
The second equality follows from the angle-sum identity for the \( \cas \) function,
\[
\cas(\alpha + \beta) = \cos(\alpha)\cas(\beta) + \sin(\alpha)\cas(-\beta),
\]
along with the fact that \( \cos(\pi a) = (-1)^a \) for all integers \( a \). Substituting this into Equation~\eqref{eq:cas-expand} yields:
\begin{align}
	\frac{1}{\sqrt{N}} \sum_{y = 0}^{N - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \ket{y}
    & = \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi a y}{N} \Big) (\ket{y} + (-1)^a \ket{y + N/2}) \nonumber \\
    & = \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \frac{1}{\sqrt{2}} (\ket{0} + (-1)^a \ket{1}) \ket{y}, \label{eq:qht-alt} 
\end{align}
In the final equality, the most significant qubit has been isolated to emphasize its contribution to the overall transformation.

We now demonstrate how to compute \( \qht_N \) recursively. For a given \( a \in \Z_N \), we decompose the basis state as \( \ket{a} = \ket{t}\ket{b} \), where \( b \) denotes the least significant bit, such that \( a = 2t + b \) for some \( t \in \Z_{N/2} \). Assuming the existence of an efficient quantum circuit for computing \( \qht_{N/2} \), we proceed to construct \( \qht_N \) in a recursive fashion. To begin the transformation on \( \ket{a} \), we introduce an ancilla qubit initialized to \( \ket{0} \), yielding the joint state \( \ket{0}\ket{t}\ket{b} \). We then proceed as follows:
\begin{align*}
	\ket{0}\ket{t}\ket{b}
    & \mapsto \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi t y}{N / 2} \Big) \ket{0} \ket{y} \ket{b} & (\mathds{1} \otimes \qht_{N / 2} \otimes \mathds{1}) \\
    & = \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{4\pi t y}{N} \Big) \ket{0} \ket{y} \ket{b} \\
    & \mapsto \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{4\pi t y}{N} \Big) (\ket{0} + \ket{1}) \ket{y}\ket{b}. & (H \otimes \mathds{1})
\end{align*}
Next, we apply a controlled negation operation, where the ancilla qubit is flipped if and only if the least significant bit \( b \) is equal to 1.
\[
    V: \ket{0}\ket{y} \mapsto \ket{0}\ket{y}, \quad \ket{1}\ket{y} \mapsto \ket{1}\ket{N / 2 -y},
\]
\[
    \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{4\pi t y}{N} \Big) \ket{0} \ket{y} \ket{b} + \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{4\pi t y}{N} \Big) \ket{1} \ket{-y} \ket{b}.
\]
By performing a change of variables in the second summation and using the identity \( \cas\left(\frac{4\pi t (N / 2 - y)}{N}\right) = \cas\left(-\frac{4\pi t y}{N}\right) \), we obtain the state:
\[
    \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \Big( \cas\Big( \frac{4\pi t y}{N} \Big) \ket{0} + \cas\Big( -\frac{4\pi t y}{N} \Big) \ket{1} \Big) \ket{y} \ket{b}.
\]

We define the single-qubit rotation \( R(\theta) \) as the unitary operator acting on a single qubit given by:\begin{equation}
    \label{eq:sine-rot}
    R(y, b) = 
    \begin{bmatrix}
        \cos(2\pi b y / N) & \sin(2\pi b y / N) \\
        -\sin(2\pi b y / N) & \cos(2\pi b y / N)
    \end{bmatrix},
\end{equation}
Now, consider the unitary \( U_R \) defined by
\[
U_R : \ket{c}\ket{y}\ket{b} \mapsto \left(R(y, b)\ket{c}\right)\ket{y}\ket{b},
\]
where \( R(y, b) \) is a single-qubit rotation depending on \( y \) and \( b \). Applying \( U_R \) followed by the controlled negation \( V \), we obtain the state:
\begin{align*}
    \ket{\phi_1}
    & = \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \Big( \cas\Big( \frac{2\pi ay}{N} \Big) \ket{0} + \cas\Big(-\frac{2\pi a(N /2 - y)}{N} \Big) \ket{1} \Big) \ket{y} \ket{b} \\
    & = \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi ay}{N} \Big) \Big( \ket{0} + (-1)^b \ket{1} \Big) \ket{y} \ket{b},
\end{align*}
Here, we have used the identity \( \cas\left(-\pi a + \frac{2\pi a y}{N}\right) = (-1)^a \cas\left(\frac{2\pi a y}{N}\right) \), along with the fact that \( (-1)^a = (-1)^b \). Applying the Hadamard transform to the first qubit yields:
\[
    \ket{\psi} = \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi ay}{N} \Big) \ket{b} \ket{y} \ket{b}
\]
Next, we uncompute the first qubit by applying a \textsc{CNOT} gate with the last qubit as control. We then apply a Hadamard transform followed by a swap operation, resulting in the state:
\begin{align*}
    \ket{\psi}
    & \mapsto \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi ay}{N} \Big) \ket{0} \ket{y} \ket{b} & (\textsc{cnot}) \\
    & \mapsto \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi ay}{N} \Big) \ket{0} \ket{y} \frac{1}{\sqrt{2}}(\ket{0} + (-1)^b \ket{1}) & (\mathds{1} \otimes H) \\
    & = \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi ay}{N} \Big) \ket{0} \ket{y} \frac{1}{\sqrt{2}}(\ket{0} + (-1)^a \ket{1}). & ((-1)^b = (-1)^a) \\
\end{align*}
The final summation matches precisely with Equation~\eqref{eq:qht-alt}, which defines the quantum Hartley transform of \( \ket{a} \). Thus, we have successfully implemented the transformation:
\[
\ket{a} \mapsto \qht_N \ket{a}.
\]
\[ \ket{0}\ket{a} \mapsto \ket{0} \qht_N\ket{a}. \]
The complete procedure is summarized in the following algorithm.

\begin{algorithm}[$\qht_N$] \
    \label{alg:qht-N}
    \begin{description}[font = \normalfont\itshape, itemsep = 0mm, parsep = 0mm, topsep = 1mm]
        \item [Input:] quantum state $\ket{\psi} \in \C^N$, where $N = 2^n$
        \item [Output:] quantum state $\qht_N\ket{\psi}$
    \end{description}

    \begin{enumerate}[itemsep = 0mm, parsep = 1mm, topsep = 1mm]
        \item Initialize an ancilla qubit to $0$ to obtain the state $\ket{0}\ket{\psi}$
        \item Compute $\mathds{1} \otimes \qht_{N / 2} \otimes \mathds{1}$ recursively.
        \item Apply $H \otimes \mathds{1}$.
        \item\label{stp:ngt} Apply the controlled negation $\ket{0}\ket{y} \mapsto \ket{0}\ket{y}, \ket{1}\ket{y} \mapsto \ket{1}\ket{N / 2 -y}$ to the first two registers.
        \item Apply the unitary $U_R$.
        \item Apply $H \otimes \mathds{1}$
        \item Apply \textsc{cnot} to the first and last qubits.
        \item Apply $\mathds{1} \otimes H$.
        \item Trace out the first qubit
    \end{enumerate}
\end{algorithm}


\begin{theorem}
    \label{thm:qht-cost}
    Algorithm \ref{alg:qht-N} is correct and can be implemented using $\approx \log^2 N + O(\log N)$ elementary gates.
\end{theorem}


\begin{proof}
    The correctness of the algorithm follows from the preceding discussion. Except for the unitary \( U_R \) and the negation unitary in Step~\ref{stp:ngt}, all steps of the algorithm can be implemented using \( O(1) \) elementary gates. The negation operation in Step~\ref{stp:ngt} can be realized using approximately \( \lceil \log N \rceil \) elementary gates.
    
    To implement the unitary \( U_R \), which requires constructing the conditional rotation operator \( R(y, b) \) for arbitrary \( y \) and \( b \), we make use of the two-qubit controlled rotations:
    \[
    R_j = \ket{0}\bra{0} \otimes \mathds{1} + \ket{1}\bra{1} \otimes
    \begin{bmatrix}
    \cos\left(\frac{2\pi 2^j}{N}\right) & \sin\left(\frac{2\pi 2^j}{N}\right) \\
    -\sin\left(\frac{2\pi 2^j}{N}\right) & \cos\left(\frac{2\pi 2^j}{N}\right)
    \end{bmatrix},
    \]
    for \( j = 0, 1, \dots, n - 1 \). When \( b = 0 \), we have \( R(y, 0) = \mathds{1} \), and when \( b = 1 \), the operator \( R(y, 1) \) is the product of those \( R_j \) for which the \( j \)th bit of \( y \) is 1. Therefore, for a binary string \( y \) of length \( k = \lceil \log y \rceil \), we can implement \( U_R \) using at most \( k \) gates from the set \( \{R_j\} \).
    
    Let \( T(N) \) denote the gate complexity of Algorithm~\ref{alg:qht-N} for an input of dimension \( N \). Assuming access to the \( R_j \) gates as elementary operations, the recurrence relation becomes
    \[
    T(N) \approx T(N / 2) + 2\log N + O(1).
    \]
    Solving this recurrence yields \( T(N) \approx \log^2 N + O(\log N) \), as claimed.
    \end{proof}
    



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Quantum Money With The Hartley Transform}
\label{sec:qm_hartley}

The quantum money scheme described earlier can also be instantiated using the quantum Hartley transform in place of the quantum Fourier transform. However, this substitution disrupts the original verification procedure. In the following sections, we demonstrate how quantum walks can be employed to resolve this issue. To pinpoint the source of the problem, we begin by restating the \( \gen \) and \( \ver \) algorithms for this Hartley-based scheme, mirroring the structure of the Fourier-based version but replacing \( \qft_G \) with \( \qht_G \). For simplicity, we take \( G = \Z_N \), and fix an element \( x \in \Z_N \).

\begin{itemize}
    \item \textbf{\( \gen \)}: Start with the state \( \ket{0}\ket{x} \), and apply the quantum Hartley transform over \( \Z_N \) to the first register, resulting in the superposition
    \[
    \frac{1}{\sqrt{N}} \sum_{g \in \Z_N} \ket{g}\ket{x}.
    \]
    Next, apply the unitary transformation \( \ket{h}\ket{y} \mapsto \ket{h}\ket{h * y} \), followed by a Hartley transform \( \qht_N \) on the first register. This yields the state
    \[
    \frac{1}{N} \sum_{h \in \Z_N} \sum_{g \in \Z_N} \cas\left(\frac{2\pi gh}{N}\right) \ket{h}\ket{g * x}
    = \frac{1}{\sqrt{N}} \sum_{h \in \Z_N} \ket{h} \ket{\Z_N^{(h)} * x}_H,
    \]
    where
    \[
    \ket{\Z_N^{(h)} * x}_H = \frac{1}{\sqrt{N}} \sum_{g \in \Z_N} \cas\left(\frac{2\pi gh}{N}\right) \ket{g * x}.
    \]
    Measure the first register to obtain a random \( h \in \Z_N \), collapsing the state to \( \ket{\Z_N^{(h)} * x}_H \). Return the pair \( (h, \ket{\Z_N^{(h)} * x}_H) \).

    \item \textbf{\( \ver(h, \ket{\psi}) \)}: First, check whether \( \ket{\psi} \) has support in \( X \). If not, return \( 0 \). Otherwise, apply \( \comph \) to the state \( \ket{0} \ket{\psi} \), and measure the first register to obtain some \( h' \in \Z_N \). Return \( 1 \) if \( h' = h \), and \( 0 \) otherwise.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Verification using quantum walks}


Given a state of the form $\ket{\Z_N^{(h)} * x}_H$, we demonstrate how the value of $h$ can be extracted using continuous-time quantum walks. For any $u \in \Z_N$, consider the Cayley graph $\Gamma = (\Z_N, E)$ generated by $Q = {\{-u, u}\}$. Let $A$ denote the adjacency matrix of $\Gamma$. The eigenvectors of $A$ are given by $\ket{\Z_N^{(h)} * x}$, with corresponding eigenvalues $\lambda_h = 2\cos(2\pi uh / N)$ for each $h \in \Z_N$. According to Theorem \ref{thm:sparse-sim} and the discussion that follows, the unitary evolution operator $W = e^{iAt}$ can be simulated efficiently to exponential precision. To proceed, we first state the following lemma.




\begin{lemma}
    \label{lem:h-eigen}
    The money state $\ket{\Z_N^{(h)} * x}_H$ is an eigenstate of $W$ with eigenvalue $e^{i\lambda_h t}$.
\end{lemma}
\begin{proof}
    We have 
    \begin{align*}
        e^{iAt} \ket{\Z_N^{(h)} * x}_H
        & = \sum_{g \in \Z_N} e^{i\lambda_gt} \ket{\Z_N^{(g)} * x} \braket{\Z_N^{(g)} * x}{\Z_N^{(h)} * x}_H \\
        & = \sum_{g \in \Z_N} e^{i\lambda_gt} \ket{\Z_N^{(g)} * x} \bra{\Z_N^{(g)} * x} \Big( \frac{1 - i}{2} \ket{\Z_N^{(h)} * x} + \frac{1 + i}{2} \ket{\Z_N^{(-h)} * x} \Big) \\
        & = e^{i\lambda_{h}t} \frac{1 - i}{2} \ket{\Z_N^{(h)} * x} + \frac{1 + i}{2} e^{i\lambda_{-h}t} \ket{\Z_N^{(-h)} * x} \\
        & = e^{i\lambda_{h}t} \ket{\Z_N^{(h)} * x}_H,
    \end{align*}
    where the second equality follows from the identity in \eqref{eq:ht-ft}, and the last equality follows from the fact that $\lambda_h = \lambda_{-h}$.
\end{proof}


By setting \( t = \poly(\log N) \), Lemma~\ref{lem:h-eigen} ensures that phase estimation can be performed using the unitary \( W \) and the eigenstate \( \ket{\Z_N^{(h)} * x}_H \), yielding an approximation \( \tilde{\lambda}_h \) of \( \lambda_h \) such that
\[
\abs{\tilde{\lambda}_h - \lambda_h} \le \frac{1}{\poly(\log N)}.
\]
From this approximation, we can extract a real number \( 0 \le \theta \le 1 \) satisfying
\[
\abs*{\theta - \frac{uh}{N}} \le \frac{1}{\poly(\log N)}.
\]
Since phase estimation can be applied with various choices of \( u \), we can obtain multiple approximations of \( \frac{uh}{N} \). As shown in~\cite{zhandry2024quantum}, selecting \( u \) appropriately allows us to reconstruct \( h \) exactly from these estimates.









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\bibliographystyle{plain}
\bibliography{references}







\end{document}



