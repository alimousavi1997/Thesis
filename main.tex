\documentclass[11pt]{article}


\usepackage[margin = 1in]{geometry}
\usepackage{article_macros}
\usepackage{authblk}



\theoremstyle{definition}
\newtheorem{algorithm}{Algorithm}
\newtheorem{construction}[theorem]{Construction}

\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}

\newcommand{\cas}{\mathrm{cas}}
\newcommand{\cht}{\mathsf{H}}
\newcommand{\qht}{\mathsf{QHT}}
\newcommand{\cft}{\mathsf{F}}
\newcommand{\qft}{\mathsf{QFT}}
\newcommand{\comph}{\mathsf{cmpIndex}}
\newcommand{\gen}{\mathsf{Gen}}
\newcommand{\ver}{\mathsf{Ver}}







\title{Quantum Walks and Application to Quantum Money}

\author{Jake Doliskani\thanks{\tt jake.doliskani@mcmaster.ca} }
% \author{Morteza Mirzaei\thanks{\tt mirzam48@mcmaster.ca} }
\author{Seyed Ali Mousavi\thanks{\tt mousas26@mcmaster.ca} }
\affil{Department of Computing and Software, McMaster University}


\date{}
\sloppy
\allowdisplaybreaks










\begin{document}
\maketitle



\newpage
\section{Introduction to Quantum Computation}
\label{sec:intro}


\section*{Introduction}

Quantum computing is a revolutionary field that combines quantum mechanics and information theory to redefine computation and information processing. In the latter part of the 20th century, scientists explored the fusion of quantum mechanics and information theory, leading to the birth of quantum information science. This field challenges the classical view of computation by introducing novel concepts like quantum bits (qubits), entanglement, and quantum superposition, which have enabled new algorithms and protocols that outpace their classical counterparts in specific tasks. Classical computers are grounded in bits, which take binary values (0 or 1). Quantum computing introduces the qubit, a fundamental unit of quantum information that can exist in a superposition of states, such as 0 and 1 simultaneously. This foundational difference enables quantum computers to process information in fundamentally new ways. Unlike technologies like DNA computing or optical computing, which describe changes in the physical substrate while retaining classical computational principles, quantum computing changes the computational paradigm itself. A quantum computer uses the principles of quantum mechanics, such as superposition and entanglement, rather than classical mechanics, to process information. In the 1980s, pioneers like Richard Feynman and David Deutsch recognized that certain quantum phenomena could not be efficiently simulated on classical computers. These insights led to the exploration of quantum Turing machines and quantum circuit models, which provided a theoretical framework for quantum computing. The discovery of quantum gates and their role in quantum algorithms formalized the field.

Early quantum algorithms demonstrated that quantum computing could solve certain problems more efficiently than classical methods. Notably, in 1994, Peter Shor introduced a polynomial-time quantum algorithm for integer factorization, which threatened classical cryptographic protocols relying on the difficulty of factoring large integers. Entanglement, a uniquely quantum phenomenon, allows particles to exhibit correlations that defy classical explanation. This property is crucial for many quantum algorithms and protocols, as it enables quantum computers to process and store information in a way that classical computers cannot. Two notable algorithms underscore the potential of quantum computing: Shor’s Algorithm, which efficiently factors integers, undermining RSA encryption and other cryptographic systems based on the hardness of factoring, and Grover’s Algorithm, which provides a quadratic speedup for unstructured search problems, such as searching an unsorted database. These algorithms exemplify the theoretical advantages of quantum computing over classical approaches, even though practical implementations remain challenging.

Quantum systems are fragile and susceptible to decoherence, where quantum states lose their coherence due to interactions with the environment. This makes maintaining quantum states for computation a significant challenge. Quantum error correction methods were developed to address decoherence and other quantum noise. The breakthrough work of Shor and Steane in the mid-1990s introduced error-correction codes that allowed reliable computation despite quantum noise. Building scalable quantum computers requires advances in hardware and experimental techniques. As of now, only small-scale quantum systems with a few qubits have been implemented successfully in laboratories. Quantum computing does not offer universal speedups for all problems. For example, Grover’s algorithm provides only a quadratic speedup for unstructured search, and certain problems remain equally challenging for both quantum and classical computers.

Quantum key distribution protocols, like BB84 and Ekert’s protocol, offer provably secure methods for communication based on the principles of quantum mechanics. Unlike classical cryptography, which relies on computational assumptions, quantum cryptography guarantees security through physical principles. The quantum perspective has provided new insights into classical computing and inspired novel classical algorithms. It has also advanced simulation techniques for quantum systems, benefiting fields like material science and chemistry. Quantum information processing has deepened our understanding of quantum mechanics, shedding light on foundational questions about quantum measurement and entanglement. For example, experiments testing Bell’s inequalities have confirmed the non-classical correlations predicted by quantum theory.

While practical quantum computing is still in its infancy, significant progress has been made. Quantum hardware companies like IBM, Google, and Rigetti have developed small-scale quantum processors capable of performing limited computations. Platforms such as Qiskit and Cirq enable researchers to experiment with quantum programming and algorithm development. Efforts to build scalable, fault-tolerant quantum computers are ongoing, alongside investigations into alternative models of quantum computation, such as topological and cluster-state quantum computing. Despite these advances, many open questions remain about the scope and ultimate power of quantum computation. While quantum computers will not replace classical ones for all tasks, they promise to revolutionize fields where their unique capabilities provide exponential speedups or new forms of computation.

Quantum computing represents a profound shift in how we understand and leverage computation. By replacing classical mechanics with quantum mechanics as the foundation for processing information, quantum computing has opened new avenues for scientific discovery and technological innovation. While challenges persist, the theoretical and experimental advances made thus far underscore the transformative potential of this exciting field.


\section*{Foundations of Quantum Computation}



\section*{Understanding a Qubit}
A qubit (quantum bit) is the fundamental unit of quantum information, analogous to a classical bit. However, unlike a classical bit, which can only exist in one of two definite states ($0$ or $1$), a qubit can exist in a linear combination, or superposition, of both states simultaneously. Mathematically, the state of a single qubit is represented as:

\begin{equation}
|\psi\rangle = \alpha |0\rangle + \beta |1\rangle
\end{equation}

Here:
\begin{itemize}
    \item $|0\rangle$ and $|1\rangle$ are the basis states (analogous to $0$ and $1$ in classical computing).
    \item $\alpha$ and $\beta$ are complex numbers known as probability amplitudes.
\end{itemize}

The normalization condition \(|\alpha|^2 + |\beta|^2 = 1\) ensures that the probabilities of measuring the qubit in either the $|0\rangle$ or $|1\rangle$ state sum to 1.

The qubit's unique ability to exist in a superposition of states is what gives quantum computers their immense computational potential, enabling them to process and store information in fundamentally different ways than classical computers.

\section*{Superposition}
Superposition is a quantum phenomenon where a qubit exists in a combination of multiple states simultaneously. For example, a qubit in the state:

\begin{equation}
|\psi\rangle = \frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle
\end{equation}

is in an equal superposition of $|0\rangle$ and $|1\rangle$. This means that if we measure the qubit, there is an equal probability (50\%) of observing it in either state.

Key properties of superposition:
\begin{itemize}
    \item \textbf{Parallelism:} When a quantum system is in superposition, it can perform computations for all possible states simultaneously. For instance, a single qubit can encode two states ($|0\rangle$ and $|1\rangle$) at the same time, while $n$ qubits can encode $2^n$ states.
    \item \textbf{Measurement Collapse:} When a qubit in superposition is measured, it collapses into one of its basis states, $|0\rangle$ or $|1\rangle$, with a probability given by $|\alpha|^2$ and $|\beta|^2$, respectively.
\end{itemize}

Superposition allows quantum systems to explore multiple possibilities in parallel, which is critical for quantum algorithms such as Grover's search or Shor's factoring.

\section*{Entanglement}
Entanglement is a uniquely quantum phenomenon where two or more qubits become correlated in such a way that the state of one qubit is directly related to the state of the other, regardless of the physical distance between them. When qubits are entangled, the measurement of one qubit instantly determines the state of the other.

An example of an entangled state for two qubits is the Bell state:

\begin{equation}
|\psi\rangle = \frac{1}{\sqrt{2}} (|00\rangle + |11\rangle)
\end{equation}

Here:
\begin{itemize}
    \item $|00\rangle$ means both qubits are in the $|0\rangle$ state.
    \item $|11\rangle$ means both qubits are in the $|1\rangle$ state.
\end{itemize}

If one qubit is measured to be $|0\rangle$, the other qubit will instantly collapse to $|0\rangle$, and similarly for $|1\rangle$, regardless of the distance between them.

Key features of entanglement:
\begin{itemize}
    \item \textbf{Non-Local Correlations:} Entanglement defies classical intuition, as it suggests that measurement outcomes are correlated even across vast distances, a phenomenon supported by experiments validating Bell's Theorem.
    \item \textbf{Applications:} Entanglement is a resource for many quantum technologies, including quantum teleportation, quantum cryptography (e.g., secure communication via the BB84 protocol), and quantum error correction.
\end{itemize}

Entanglement, along with superposition, forms the backbone of quantum computing and quantum communication, enabling capabilities that are impossible in the classical world.




\subsection*{Quantum Gates and Circuits}


Quantum logic gates are the fundamental building blocks of quantum circuits, manipulating qubits—the basic units of quantum information. Unlike classical logic gates, quantum gates are reversible and represented by unitary matrices, ensuring the preservation of quantum information.

\subsection*{Key Quantum Logic Gates}

\subsubsection*{1. Pauli-X Gate (NOT Gate)}
\textbf{Operation:} Flips the state of a qubit from $|0\rangle$ to $|1\rangle$ and vice versa. \\
\textbf{Matrix Representation:}
\[
X = 
\begin{bmatrix}
0 & 1 \\
1 & 0
\end{bmatrix}
\]

\subsubsection*{2. Hadamard Gate (H Gate)}
\textbf{Operation:} Creates a superposition state, transforming $|0\rangle$ into $\frac{|0\rangle + |1\rangle}{\sqrt{2}}$ and $|1\rangle$ into $\frac{|0\rangle - |1\rangle}{\sqrt{2}}$. \\
\textbf{Matrix Representation:}
\[
H = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 & 1 \\
1 & -1
\end{bmatrix}
\]

\subsubsection*{3. Controlled-NOT Gate (CNOT Gate)}
\textbf{Operation:} A two-qubit gate that flips the state of the target qubit if the control qubit is in the state $|1\rangle$. \\
\textbf{Matrix Representation:}
\[
CNOT =
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0
\end{bmatrix}
\]

\subsubsection*{4. Toffoli Gate (CCNOT Gate)}
\textbf{Operation:} A three-qubit gate that flips the state of the target qubit if both control qubits are in the state $|1\rangle$. \\
\textbf{Matrix Representation:}
\[
CCNOT =
\begin{bmatrix}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0
\end{bmatrix}
\]

\subsection*{Universal Gates}
A set of gates is considered \textbf{universal} if any unitary operation can be approximated to arbitrary precision using a sequence of gates from this set. For example, single-qubit rotation gates combined with the CNOT gate form a universal set, enabling the construction of any quantum algorithm.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction to Quantum Walks}


The concept of a \textit{quantum walk} is a quantum analog of the classical random walk and plays a significant role in quantum algorithms. There are two main types of quantum walks: \textit{continuous-time} and \textit{discrete-time} quantum walks, both of which exhibit behaviors that are significantly different from classical random walks.

\section*{Continuous-Time Quantum Walks}


Classical continuous-time random walks (Markov chains) are a foundational concept in stochastic processes, where time is treated as a continuous variable. In this framework, a walker moves from one vertex of a graph to an adjacent vertex at any time, with probabilities evolving over time. The probability of the walker being at a vertex can be visualized as a liquid seeping from one vertex to its neighbors. Initially, the walker is most likely to be found at the starting vertex, but as time progresses, the probability shifts to neighboring vertices. This dynamic is governed by a constant transition rate \( \gamma \), uniform across all vertices and time.

To model this mathematically, the probability of transitioning from one vertex to another in an infinitesimal time interval \( \Delta t \) is proportional to \( \gamma \Delta t \). For a vertex \( x_j \) with degree \( d_j \) (the number of neighboring vertices), the probability of the walker staying on \( x_j \) is 

\[
1 - d_j \gamma \Delta t,
\]

while the probability of transitioning to a neighboring vertex is 

\[
\gamma \Delta t.
\]

The evolution of probabilities over time is captured by the transition matrix \( M(t) \), where the entry \( M_{ij}(t) \) represents the probability of transitioning from vertex \( x_j \) to vertex \( x_i \) in time \( t \). The dynamics of the system are described by a differential equation derived from the transition matrix and an auxiliary matrix \( H \), known as the generating matrix. This equation, 

\[
\frac{dM(t)}{dt} = -H M(t),
\]

has a solution expressed as 

\[
M(t) = e^{-Ht},
\]

which allows for the computation of probability distributions at any given time. The solution is verified using the Taylor series expansion of the exponential function.

The passage from classical continuous-time Markov chains to quantum walks involves a standard quantization process. In classical random walks, probabilities evolve via the transition matrix \( M \). In contrast, the quantization process replaces the vector of probabilities with a state vector (probability amplitudes) and the non-unitary transition matrix with a unitary evolution operator, as required by quantum mechanics. This involves transforming the generating matrix \( H \) into a Hermitian operator and then constructing a unitary operator 

\[
U(t) = e^{-iHt}
\]

by multiplying \( H \) with the imaginary unit \( i \).

In a continuous-time quantum walk, the quantum state evolves over time according to the unitary operator \( U(t) \). If the initial state of the system is \( |\psi(0)\rangle \), the state at time \( t \) is given by 

\[
|\psi(t)\rangle = U(t) |\psi(0)\rangle.
\]

The probability distribution for observing the walker at a specific vertex \( k \) is computed as 

\[
p_k = |\langle k | \psi(t) \rangle|^2,
\]

where \( |k\rangle \) represents the state corresponding to vertex \( k \).

The continuous-time quantum walk introduces several key differences from its classical counterpart. Unlike classical random walks, which rely on probabilities, quantum walks involve probability amplitudes, enabling interference effects. These effects allow quantum walks to explore the graph more efficiently, leading to applications in quantum algorithms with speedups over classical approaches. Additionally, the transition matrix in classical random walks is replaced with a Hermitian operator in the quantum case, ensuring unitary evolution.



*********Examples and further discussions here*********


% Overall, the transition from classical continuous-time Markov chains to continuous-time quantum walks highlights fundamental differences between classical and quantum dynamics, particularly the role of interference and the constraints of unitary evolution in quantum systems. These differences underscore the potential of quantum walks in quantum computing and algorithm design.




\section*{Discrete-Time Quantum Walks}
*******************
The discrete-time coined quantum walk (DTQW) is a quantum analog of classical random walks, leveraging the principles of quantum mechanics to achieve unique computational and dynamical properties. It is defined on a graph or lattice, with the walker's state described by both its position and an internal "coin" state. The walker's position \( n \) on a one-dimensional lattice (line) is represented by a vector \( |n\rangle \) in an infinite-dimensional Hilbert space \( \mathcal{H}_P \), where the computational basis for \( \mathcal{H}_P \) is 

\[
\{ |n\rangle : n \in \mathbb{Z} \}.
\]

The walker's internal state, or "coin," is represented by a two-dimensional Hilbert space \( \mathcal{H}_C \) with basis states \( |0\rangle \) and \( |1\rangle \). The coin state determines the direction of the walker's movement, and the total state of the system resides in the tensor product space 

\[
\mathcal{H} = \mathcal{H}_C \otimes \mathcal{H}_P,
\]

combining the coin and position spaces.

The dynamics of the walk are governed by two key operators: the coin operator and the shift operator. The coin is represented by a unitary matrix \( C \) acting on \( \mathcal{H}_C \). Common choices include the Hadamard matrix, which creates superpositions of the coin states. The Hadamard coin operator \( H \) is defined as 

\[
H = \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}.
\]

The shift operator \( S \) moves the walker based on the coin state. For example, if the coin state is \( |0\rangle \), the walker moves to \( |n+1\rangle \), and if the coin state is \( |1\rangle \), the walker moves to \( |n-1\rangle \). The shift operator is explicitly given by 

\[
S = \sum_{n} |n+1\rangle \langle n| \otimes |0\rangle \langle 0| + |n-1\rangle \langle n| \otimes |1\rangle \langle 1|.
\]

The evolution of the system is described by the unitary operator 

\[
U = S \cdot (I \otimes C),
\]

where \( I \) is the identity operator on \( \mathcal{H}_P \). The state of the walker at time \( t+1 \) is given by 

\[
|\psi(t+1)\rangle = U |\psi(t)\rangle.
\]

Consider a quantum walk on a one-dimensional lattice. The walker's state evolves in superposition, allowing it to explore multiple paths simultaneously. Interference between these paths leads to faster spreading compared to classical random walks.

Key features of DTQW include superposition, where the walker exists in a superposition of positions and coin states, enabling parallel exploration of multiple paths; interference, where quantum interference enhances or suppresses certain paths, leading to non-classical behavior; and quadratic speedup, where quantum walks spread faster than classical random walks, often quadratically, which is advantageous for algorithmic applications.

DTQWs are used in quantum algorithms, such as quantum search and graph traversal, and in simulating physical systems like energy transport in photosynthesis. They also serve as a framework for universal quantum computation. The discrete-time quantum walk is a powerful tool in quantum computing, offering a rich interplay between quantum mechanics and graph theory. Its ability to exploit superposition and interference enables applications in algorithm design, simulation, and computation, making it a cornerstone of quantum information science.

*********Examples and further discussions here*********


\subsection*{Comparison of Models}

From a computational standpoint, both continuous-time and discrete-time quantum walks offer distinct advantages. The continuous-time quantum walk is often considered more natural because it does not require expanding the state space, making it simpler to define and typically easier to analyze. For example, while the exponential speedup demonstrated by continuous-time quantum walks is widely believed to extend to the discrete-time model, the dynamics of the latter are more complex. To date, no rigorous analysis has been provided to confirm this extension.

In contrast, the discrete-time quantum walk is generally more straightforward to implement using quantum circuits. Implementing continuous-time quantum walks, however, often relies on techniques that require the graph's maximum degree to be small. This constraint makes certain algorithms challenging to replicate using continuous-time quantum walks. Therefore, while continuous-time quantum walks excel in simplicity and analytical tractability, discrete-time quantum walks offer greater practicality and ease of implementation in quantum computing applications.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Group Actions}

Group actions provide a framework for understanding how groups interact with sets, formalizing the concept of applying transformations systematically. They capture the symmetries and structure-preserving transformations of objects, making them fundamental in mathematics and its applications. Group actions describe transformations through a set of rules that ensure consistency and compatibility with the underlying group operations. This concept is pivotal in cryptography, where the symmetries and operations of groups underpin many secure systems.

In cryptography, group actions are critical to protocols like Elliptic Curve Cryptography (ECC), which relies on the difficulty of reversing group-based operations to ensure security. Isogeny-based cryptography, a post-quantum cryptographic candidate, uses group actions on elliptic curves to create complex mathematical problems resistant to quantum attacks. Similarly, lattice-based and code-based cryptography use group actions to study transformations in structures that form the basis for secure communication systems. Non-abelian group actions are being explored for their potential to create quantum-resistant algorithms.

In quantum computing, group actions are central to quantum walks, a quantum equivalent of classical random walks. Quantum walks leverage group actions to describe the evolution of quantum states and exploit the symmetries of these states for tasks like search, optimization, and cryptographic protocol design. This makes them valuable in constructing secure quantum algorithms and protocols, particularly in quantum key distribution and graph-based cryptography. Overall, group actions bridge abstract mathematical theory with practical applications in classical and quantum cryptography.


\section*{Definition of Group Action}

Group actions form a bridge between group theory and other mathematical structures, offering a systematic way to study symmetry, transformations, and invariants. Let us delve deeper into their properties, classifications, and applications.

\subsection*{Formal Definition}

A \textbf{group action} of a group \( G \) on a set \( X \) is a map \( \cdot : G \times X \to X \) that satisfies:

\begin{enumerate}
    \item \textbf{Identity Property}:
    \[
    e \cdot x = x \quad \text{for all } x \in X,
    \]
    where \( e \) is the identity element of \( G \).

    \item \textbf{Compatibility (Associativity)}:
    \[
    (gh) \cdot x = g \cdot (h \cdot x) \quad \text{for all } g, h \in G, \, x \in X.
    \]
\end{enumerate}

Alternatively, the group action can be viewed as a homomorphism \( \phi : G \to \text{Sym}(X) \), where \( \text{Sym}(X) \) is the group of all permutations of \( X \).

\subsection*{Types of Group Actions}

\begin{enumerate}
    \item \textbf{Faithful Action}: The action is faithful if \( g \cdot x = x \) for all \( x \in X \) implies \( g = e \). Equivalently, the homomorphism \( \phi \) is injective.
    
    \item \textbf{Transitive Action}: The action is transitive if, for any \( x, y \in X \), there exists \( g \in G \) such that \( g \cdot x = y \). In this case, \( X \) consists of a single orbit.
    
    \item \textbf{Free Action}: The action is free if \( g \cdot x = x \) implies \( g = e \) for all \( x \in X \).
    
    \item \textbf{Regular Action}: The action is both transitive and free, meaning there is exactly one \( g \in G \) for each pair \( (x, y) \) such that \( g \cdot x = y \).
    
    \item \textbf{Effective Action}: The action is effective if the only group element acting as the identity on \( X \) is \( e \).
\end{enumerate}

\subsection*{Key Concepts in Group Actions}

\begin{enumerate}
    \item \textbf{Orbits}:
    For \( x \in X \), the \textbf{orbit} of \( x \) is:
    \[
    \text{Orb}(x) = \{g \cdot x \mid g \in G\}.
    \]
    Orbits partition the set \( X \), and each orbit is a subset where the action appears ``connected.''

    \item \textbf{Stabilizer Subgroup}:
    The \textbf{stabilizer} of \( x \in X \) is:
    \[
    \text{Stab}_G(x) = \{g \in G \mid g \cdot x = x\}.
    \]
    It is a subgroup of \( G \) and describes the symmetries that leave \( x \) unchanged.

    \item \textbf{Orbit-Stabilizer Theorem}:
    This theorem links the size of an orbit and its stabilizer:
    \[
    |G| = |\text{Orb}(x)| \cdot |\text{Stab}_G(x)|.
    \]

    \item \textbf{Fixed Points}:
    A point \( x \in X \) is a \textbf{fixed point} if \( g \cdot x = x \) for all \( g \in G \). The set of fixed points is:
    \[
    \text{Fix}(G) = \{x \in X \mid g \cdot x = x, \, \forall g \in G\}.
    \]

    \item \textbf{Invariant Subsets}:
    A subset \( Y \subseteq X \) is \textbf{invariant} under the action if \( g \cdot y \in Y \) for all \( g \in G \) and \( y \in Y \).
\end{enumerate}




\section*{Groups and Characters}


\section{Abelian Groups}

An \textbf{abelian group} (also called a \textbf{commutative group}) is a set \( G \) equipped with a binary operation \( \cdot \) (usually written as addition \( + \) or multiplication \( \cdot \)) that satisfies the following four group axioms, along with an additional \textbf{commutativity} property.

\subsection{Axioms of an Abelian Group}
A set \( G \) with a binary operation \( \cdot \) is an \textbf{abelian group} if the following conditions hold:

\begin{enumerate}
    \item \textbf{Closure}:  
    For all \( a, b \in G \), the operation \( a \cdot b \) produces another element in \( G \):

    \[
    a \cdot b \in G.
    \]

    \item \textbf{Associativity}:  
    For all \( a, b, c \in G \), the operation satisfies:

    \[
    (a \cdot b) \cdot c = a \cdot (b \cdot c).
    \]

    \item \textbf{Identity Element}:  
    There exists an element \( e \in G \) such that for all \( a \in G \):

    \[
    e \cdot a = a \cdot e = a.
    \]

    This element \( e \) is called the \textbf{identity element}.

    \item \textbf{Inverse Element}:  
    For every element \( a \in G \), there exists an element \( a^{-1} \in G \) such that:

    \[
    a \cdot a^{-1} = a^{-1} \cdot a = e.
    \]

    \item \textbf{Commutativity (Abelian Property)}:  
    For all \( a, b \in G \), the operation is \textbf{commutative}:

    \[
    a \cdot b = b \cdot a.
    \]

\end{enumerate}

Since abelian groups satisfy commutativity, they allow more flexible mathematical operations and structure, leading to applications in algebra, number theory, and topology.

\subsection{Characters of Abelian Groups}
Let \( G \) be an abelian group. A function  

\[
\chi: G \to \mathbb{C}^{\times}
\]

that maps \( G \) to the group of nonzero complex numbers  \(\mathbb{C}^{\times} = \mathbb{C} \setminus \{0\}\), is called a \textbf{character} of \( G \) if it is a \textbf{group homomorphism}. That is, for all \( g_1, g_2 \in G \), the function satisfies:  

\[
\chi(g_1 g_2) = \chi(g_1) \chi(g_2).
\]

\section*{Character Values for Finite Groups}

If \( \chi \) is a character of a finite group (or more generally, a torsion group) \( G \), then each function value \( \chi(g) \) is a root of unity. This follows because, for each \( g \in G \), there exists some integer \( k \in \mathbb{N} \) such that:  

\[
g^k = e.
\]

Applying \( \chi \) to both sides, we obtain:  

\[
\chi(g)^k = \chi(g^k) = \chi(e) = 1.
\]


\section*{Number of Characters in a Finite Abelian Group}

A \textbf{finite abelian group} of order \( n \) has exactly \( n \) distinct characters, denoted by:  

\[
\chi_1, \chi_2, \dots, \chi_n.
\]

The function \( \chi_1 \), defined by:  

\[
\chi_1(g) = 1, \quad \forall g \in G,
\]

is called the \textbf{principal character} of \( G \). The remaining \( n-1 \) characters are referred to as \textbf{non-principal characters}.

\section*{Character Group}

If \( G \) is an abelian group, the set of characters \( \{\chi_k\} \) forms an abelian group under pointwise multiplication, defined as:  

\[
(\chi_j \chi_k)(g) = \chi_j(g) \chi_k(g), \quad \forall g \in G.
\]

This group is called the \textbf{character group} of \( G \) and is often denoted as $\hat{G}$.  
The \textbf{identity element} of \( \hat{G} \) is the principal character \( \chi_1 \), and the \textbf{inverse} of a character \( \chi_k \) is its reciprocal:  

\[
(\chi_k)^{-1} = \frac{1}{\chi_k}.
\]

If \( G \) is finite of order \( n \), then the character group \( \hat{G} \) is also of order \( n \). In this case, since  

\[
|\chi_k(g)| = 1, \quad \forall g \in G,
\]

the inverse of a character is simply its \textbf{complex conjugate}:

\[
\chi_k^{-1}(g) = \overline{\chi_k(g)}.
\]



\section{Quantum Fourier Transform}

The \textbf{Quantum Fourier Transform (QFT)} is one of the most fundamental unitary transformations in quantum computing. It plays a crucial role in quantum algorithms, including Shor’s algorithm for integer factorization and quantum phase estimation. The QFT is the quantum analog of the classical discrete Fourier transform (DFT) but operates on quantum states, enabling efficient quantum computation of Fourier coefficients.

In this section, we discuss the QFT in the context of abelian groups, with a focus on its implementation over \( \mathbb{Z}_{2^n} \), one of the most commonly used finite groups in quantum algorithms, including quantum walks.

\section{Quantum Fourier Transform Over an Abelian Group}

Let \( G \) be an abelian group. The \textbf{Quantum Fourier Transform} over \( G \) is defined as:

\[
F_G = \frac{1}{\sqrt{|G|}} \sum_{x \in G} \sum_{y \in \hat{G}} \chi_y(x) | y \rangle \langle x |
\]

where:

\begin{itemize}
    \item \( \hat{G} \) is a complete set of characters of \( G \).
    \item \( \chi_y(x) \) denotes the \( y \)th character of \( G \), evaluated at \( x \).
    \item \( |x\rangle \) and \( |y\rangle \) are quantum states corresponding to elements of \( G \) and its dual group \( \hat{G} \).
\end{itemize}

Since \( G \) and \( \hat{G} \) are isomorphic, it is often useful to label the elements of \( \hat{G} \) using elements of \( G \). The unitary nature of the QFT follows from the \textbf{orthogonality of characters}.




\subsection{QFT Over \( \mathbb{Z}_{2^n} \)}

The QFT over \( G = \mathbb{Z}_{2^n} \) is defined as:

\[
F_{\mathbb{Z}_{2^n}} = \frac{1}{\sqrt{2^n}} \sum_{x,y \in \mathbb{Z}_{2^n}} \omega_{2^n}^{xy} | y \rangle \langle x |
\]

where:

\[
\omega_m = e^{2\pi i / m}
\]

is the \textbf{primitive} \( m \)th root of unity. This transformation maps an input basis state \( |x\rangle \) as follows:

\[
| x \rangle \to \frac{1}{\sqrt{2^n}} \sum_{y \in \mathbb{Z}_{2^n}} \omega_{2^n}^{xy} | y \rangle.
\]

This equation represents a \textbf{linear transformation} where each input state \( |x\rangle \) is mapped to a superposition of all basis states, weighted by phase factors.

\subsection{Binary Representation and QFT Implementation}

To implement this transformation efficiently, it is useful to express \( x \) and \( y \) in binary form:

\[
x = x_{n-1} x_{n-2} \dots x_1 x_0.
\]

The exponent in the Fourier transform formula can then be rewritten using its binary expansion:

\[
\omega_{2^n}^{xy} = e^{2\pi i x \sum_{k=0}^{n-1} y_k 2^k / 2^n}.
\]

Rewriting the transformation explicitly:

\[
| x \rangle \to \frac{1}{\sqrt{2^n}} \sum_{y \in \mathbb{Z}_{2^n}} e^{2\pi i x \sum_{k=0}^{n-1} y_k 2^k / 2^n} | y \rangle.
\]

This can be decomposed into a \textbf{tensor product of single-qubit states}, where each qubit state depends on the least significant bits of \( x \):

\[
\bigotimes_{k=0}^{n-1} | z_k \rangle.
\]

where

\[
| z_k \rangle = \frac{1}{\sqrt{2}} ( | 0 \rangle + e^{2\pi i ( x_0 2^{-n+k} + x_1 2^{-n+k+1} + \dots + x_{n-1} 2^{-1} )} | 1 \rangle ).
\]

This decomposition highlights the \textbf{hierarchical dependence of qubits on the binary digits of \( x \)}, making it possible to implement the QFT using \textbf{Hadamard gates and controlled phase shift gates}.


\subsection*{Cayley graphs}

A Cayley graph is a graphical representation of a group based on a chosen set of generators. It is widely used in algebra, combinatorics, and theoretical computer science to study group structures and their applications in network theory, quantum computing, and cryptography.


\section*{Definition of Cayley Graphs}

A \textit{Cayley graph} is a graph that encodes the structure of a group with respect to a chosen generating set. Formally, let \( G \) be a group and \( S \) be a subset of \( G \) that serves as a generating set, meaning every element of \( G \) can be expressed as a finite product of elements from \( S \). The Cayley graph \( \Gamma(G, S) \) is defined as follows. The vertex set of the graph consists of the elements of \( G \), where each vertex corresponds to a unique group element. The edge set is constructed by drawing a directed edge from vertex \( g \) to vertex \( gs \) for each \( g \in G \) and \( s \in S \). If the generating set \( S \) is symmetric, meaning that whenever \( s \in S \), its inverse \( s^{-1} \) is also in \( S \), then the Cayley graph is undirected; otherwise, it is a directed graph.
For example, For the cyclic group \( G = \mathbb{Z}_n = \{0,1,2,\dots, n-1\} \) with the generating set \( S = \{\pm 1\} \), the Cayley graph forms a cycle graph. In this graph, each vertex \( j \) is connected to \( j+1 \mod n \) and \( j-1 \mod n \), creating a cyclic structure.


\section*{Quantum walks on Cayley graphs}
Quantum walks on Cayley graphs play a crucial role in quantum computing, quantum search algorithms, and mathematical physics due to their deep connection with group theory and symmetry. The structured nature of Cayley graphs, derived from group elements and generators, ensures uniform exploration of the graph, leading to faster propagation compared to classical random walks. This property is particularly valuable in quantum algorithms, where quantum walks on Cayley graphs have been used to achieve exponential speedups in search and optimization problems. Additionally, their spectral properties, determined by the adjacency matrix and Fourier analysis on groups, provide insights into mixing times, state localization, and quantum transport phenomena. These advantages make Cayley graphs an essential framework for designing scalable and efficient quantum algorithms, offering a powerful bridge between algebraic structures and quantum mechanics.




\section*{Discrete-Time Quantum Walk on Cayley Graphs}

A discrete-time quantum walk on a Cayley graph requires a coin operator to maintain unitary evolution.

\subsection*{State Space}
The Hilbert space of the quantum walk is:
\[
\mathcal{H} = \mathcal{H}_G \otimes \mathcal{H}_C,
\]
where:
\begin{itemize}
    \item \( \mathcal{H}_G \) is the space spanned by group elements (vertices).
    \item \( \mathcal{H}_C \) is the coin space, which determines movement directions.
\end{itemize}

Each state is represented as:
\[
|\psi\rangle = \sum_{g \in G} \sum_{s \in S} \alpha_{g,s} |g\rangle \otimes |s\rangle,
\]
where \( |g\rangle \) is the vertex state and \( |s\rangle \) represents the coin state.

\subsection*{Evolution Operators}
\textbf{Coin Flip Operator (\( C \))}: This unitary operator acts on the coin space to create a superposition of movement directions. A common choice is the Grover or Hadamard operator.

\textbf{Shift Operator (\( S \))}: Moves the walker according to the group structure:
\[
S |g\rangle \otimes |s\rangle = |gs\rangle \otimes |s\rangle.
\]
This means that if the walker is at vertex \( g \) with a coin state \( s \), it moves to \( gs \).

\textbf{Full Step Evolution}:
\[
U = S (C \otimes I),
\]
where \( U \) is the total unitary evolution per step.

The probability of finding the walker at a particular vertex \( g \) after \( t \) steps is given by:
\[
P(g, t) = \sum_{s \in S} |\langle g, s | \psi(t) \rangle |^2.
\]


\section*{Continuous-Time Quantum Walk on Cayley Graphs}

A continuous-time quantum walk on a Cayley graph follows a different evolution, governed by the Hamiltonian.

\subsection*{Hamiltonian and Evolution}
The evolution of the quantum walk is determined by the Schrödinger equation:
\[
i \frac{d}{dt} |\psi(t)\rangle = H |\psi(t)\rangle.
\]
Here, the Hamiltonian \( H \) is usually chosen as:
\[
H = A(\Gamma(G,S)),
\]
where \( A \) is the adjacency matrix of the Cayley graph:

\[
A_{g,h} =
\begin{cases}
1, & \text{if } h = gs \text{ for some } s \in S, \\
0, & \text{otherwise}.
\end{cases}
\]
 Alternatively, the Laplacian \( L \) can be used:
\[
H = L = D - A,
\]
where \( D \) is the degree matrix:

\[
D_{ij} =
\begin{cases}
\deg(v_i), & \text{if } i = j, \\
0, & \text{otherwise}.
\end{cases}
\]

Here, \( \deg(v_i) \) is the degree of vertex \( v_i \), which is the number of edges connected to \( v_i \).


The solution to the quantum walk is given by:
\[
|\psi(t)\rangle = e^{-i H t} |\psi(0)\rangle.
\]
This means the probability amplitude at a vertex \( g \) spreads over time according to the unitary evolution operator \( e^{-i H t} \).


\section*{Spectral Decomposition of the Adjacency Matrix of a Cayley Graph}

The spectral decomposition of the adjacency matrix of a Cayley graph involves expressing the adjacency matrix in terms of its eigenvalues and eigenvectors. This decomposition is particularly useful for understanding the behavior of quantum walks, graph connectivity, expansion properties, and random walks on the graph.

Spectral decomposition expresses \( A \) in terms of its eigenvalues and eigenvectors:
\[
A = \sum_{j} \lambda_j P_j,
\]
where:
\begin{itemize}
    \item \( \lambda_j \) are the eigenvalues of \( A \).
    \item \( P_j \) are the projection matrices onto the corresponding eigenspaces.
\end{itemize}

Since Cayley graphs are highly structured, their eigenvalues and eigenvectors often have explicit formulas based on group representation theory and Fourier analysis on groups.

For a finite group \( G \), the Fourier transform on groups helps diagonalize \( A \). The eigenvalues of \( A \) are computed as:
\[
\lambda_\rho = \sum_{s \in S} \rho(s),
\]
where \( \rho \) is an irreducible representation of \( G \). The set of eigenvalues depends on the sum over generators in the group's representation.

For Abelian groups (e.g., \( \mathbb{Z}_n \)), the irreducible representations are characters, simplifying the spectral decomposition.

For non-Abelian groups, the decomposition involves matrix-valued representations.

\subsection*{Example: Cyclic Group \( \mathbb{Z}_n \)}

Consider the Cayley graph of \( \mathbb{Z}_n \) with generator set \( S = \{\pm 1\} \), which forms a cycle graph. The adjacency matrix is:
\[
A_{jk} =
\begin{cases}
1, & \text{if } k = j \pm 1 \mod n, \\
0, & \text{otherwise}.
\end{cases}
\]

Its eigenvalues are:
\[
\lambda_k = 2\cos\left(\frac{2\pi k}{n}\right),
\]
with eigenvectors given by the discrete Fourier transform (DFT) basis:
\[
\psi_k(j) = e^{\frac{2\pi i k j}{n}}.
\]

This result generalizes to other Abelian groups, where the eigenvectors are given by the Fourier basis of the group.



\subsection*{Quantum walks from Group Actions}
The spectral decomposition of the adjacency matrix of a Cayley graph generated by a general group action $G$ provides insights into the structure and properties of the graph. This decomposition leverages the symmetries of the group $G$ and representation theory to analyze the eigenvalues and eigenvectors of the adjacency matrix.

  
Let $G$ be a finite group, and let $X$ be a set on which $G$ acts via a group action $G \times X \to X$. A Cayley graph can be constructed based on this action, where
the vertices are the elements of the set $X$, and For each $g \in G$ and $x \in X$, there is an edge between $x$ and $g *	x$, where $g * x$ is the action of $g$ on $x$.


If the generating set $S \subset G$ is symmetric (i.e., $s \in S \implies s^{-1} \in S$), then the Cayley graph is undirected. Otherwise, it may be directed.



The adjacency matrix $A$ of the Cayley graph is a matrix that encodes the edges of the graph:

\[
A_{x,y} =
\begin{cases}
1, & \text{if there exists } g \in G \text{ such that } y = g * x, \\
0, & \text{otherwise}.
\end{cases}
\]

The adjacency matrix is symmetric if the group action preserves symmetry, which happens if $G$ is acting via an involution, i.e., if for every generator $g \in G$, its inverse is also a generator. It also inherits the symmetries of the group action. That is, the group $G$ acts on the vertices of the graph, and the adjacency matrix commutes with the action of the group. This means that the adjacency matrix $A$ is highly structured, and its eigenvalues can be computed using the representation theory of the group $G$.


The eigenvalues of the adjacency matrix correspond to the eigenvalues of these blocks $\rho(A)$, and the multiplicities of the eigenvalues are related to the dimensions of the corresponding irreducible representations.

The spectral decomposition of the adjacency matrix $A$ can be written as:

\[
A = \sum_{i} \lambda_{i} v_{i} v_{i}^{\top},
\]

where:

- $\lambda_{i}$ are the eigenvalues,
- $v_{i}$ are the corresponding eigenvectors (which lie in the spaces corresponding to the irreducible representations),
- $v_{i} v_{i}^{\top}$ is the outer product of the eigenvector $v_{i}$ with itself.

The eigenvectors $v_{i}$ are related to the characters of the group $G$. Specifically, the characters of irreducible representations of $G$ help determine the eigenvalues of $A$. If $\chi_{\rho}$ denotes the character of the irreducible representation $\rho$, then the eigenvalues are given by:

\[
\lambda_{\rho} = \frac{1}{|G|} \sum_{g \in G} \chi_{\rho}(g) A(g),
\]

where $A(g)$ is the action of $g$ as represented in the adjacency matrix.


\[
*************Further discussions Here***************
\]


\section{Applicaions}
\section{Quantum Money}


\section*{Introduction to Quantum Money}
Quantum money is a revolutionary concept in cryptography that uses quantum mechanics to create a form of currency that is provably secure against forgery. Originally introduced by physicist Stephen Wiesner in the 1970s, quantum money represents one of the earliest proposed applications of quantum information science. By encoding information into quantum states, quantum money exploits the fundamental principles of quantum mechanics to provide security features unattainable by classical systems.

% \section*{How Quantum Money Works}
% At its core, quantum money relies on two key principles of quantum mechanics: the \textit{no-cloning theorem} and the \textit{observer effect}.

% \subsection*{Encoding Information in Quantum States}
% \begin{itemize}
%     \item Each quantum bill contains a unique quantum state, such as a set of qubits encoded in superposition.
%     \item These states are generated and stored by the issuing authority (e.g., a central bank) using a secret algorithm.
% \end{itemize}

% \subsection*{Verification Process}
% \begin{itemize}
%     \item The issuing authority also generates a verification protocol, allowing a legitimate quantum bill to be authenticated.
%     \item When a user presents a quantum bill for verification, the authority measures the encoded quantum states using the pre-determined protocol.
%     \item If the measured states align with the expected values, the bill is deemed valid.
% \end{itemize}

% \subsection*{Unforgeability}
% \begin{itemize}
%     \item Due to the \textit{no-cloning theorem}, it is impossible to copy an unknown quantum state without altering it.
%     \item Any attempt to measure or duplicate the quantum state results in a disturbance detectable during verification.
% \end{itemize}

% \section*{Key Principles Underpinning Quantum Money}
% \begin{enumerate}
%     \item \textbf{No-Cloning Theorem:} The no-cloning theorem states that an unknown quantum state cannot be perfectly copied. This makes quantum money inherently secure, as counterfeiters cannot reproduce the quantum states encoded in legitimate currency.
%     \item \textbf{Measurement Disturbance:} Observing or measuring a quantum state generally alters it. This ensures that any unauthorized attempt to inspect the quantum money will render it invalid, as the encoded states will no longer match their original form.
%     \item \textbf{Randomness and Superposition:} Quantum money utilizes superposition to encode information. For example, a single qubit in superposition may represent both $0$ and $1$ simultaneously until measured. The randomness of these states makes predicting or reproducing them without knowledge of the original encoding impossible.
%     \item \textbf{Entanglement (Optional Feature):} Some implementations of quantum money involve quantum entanglement, where pairs of quantum states are interconnected. Changes to one entangled state directly affect its pair, adding another layer of security against forgery.
% \end{enumerate}

\section*{Benefits of Quantum Money}
\begin{itemize}
    \item \textbf{Unforgeable:} Classical currency, both physical and digital, can be counterfeited with enough effort and resources. Quantum money, however, is fundamentally unforgeable due to the laws of quantum physics.
    \item \textbf{Decentralized Verification:} In some theoretical models, quantum money can be verified without contacting the issuing authority, enabling decentralized systems for authentication.
    \item \textbf{Enhanced Privacy:} The unique encoding of each quantum bill could allow for privacy-preserving transactions, as the details of the transaction need not be linked to the bill's verification.
\end{itemize}

\subsection{Quantum Money From Group Actions}
A public-key quantum money scheme consists of two QPT algorithms: 
\begin{itemize}
\item $\gen(1^\lambda)$: This algorithm takes a security parameter $\lambda$ as input and outputs a pair $(s, \rho_s)$, where $s$ is a binary string called the serial number, and $\rho_s$ is a quantum state called the banknote. The pair $(s, \rho_s)$, or simply $\rho_s$, is sometimes denoted by $\$$.
\item $\ver(s, \rho_s)$ This algorithm takes a serial number and an alleged banknote as input and outputs either $1$ (accept) or $0$ (reject).
\end{itemize}

The quantum money scheme is said to be \textit{correct} if genuine banknotes generated by $\gen$ are accepted by $\ver$ with high probability. More formally:
\[ \Pr[\ver(s, \rho_s) = 1 : (s, \rho_s) \gets \gen(1^\lambda)] \ge 1 - \negl(\lambda). \]
where the probability is taken over the randomness of $\gen$ and $\ver$. The scheme $(\gen, \ver)$ is said to be secure if, given a genuine bill $(s, \rho_s)$, no QPT algorithm $\mathcal{A}$ can produce two (possibly entangled) bills $(s, \rho_1)$ and $(s, \rho_2)$ that are both accepted by $\ver$ with non-negligible probability. More formally:
\[ \Pr\left[ \ver(s, \rho_1) = \ver(s, \rho_2) = 1 : \substack{(s, \rho_s) \gets \gen(1^\lambda) \\ (\rho_1, \rho_2) \gets \mathcal{A}(s, \rho_s)} \right] \le \negl(\lambda). \]

We now briefly outline the quantum money construction from \cite{zhandry2024quantum}, which is based on abelian group actions. Let $\{(G_\lambda, X_\lambda, *)\}_{\lambda \in J}$, where $J \subset \N$, be a collection of cryptographic group actions for abelian groups $G_\lambda$, and let $x_\lambda \in X_\lambda$ be a fixed element. The $\gen$ and $\ver$ algorithms are as follows:
\begin{itemize}
\item $\gen(1^\lambda)$. Begin with the state $\ket{0}\ket{x_\lambda}$, and apply the quantum Fourier transform over $G_\lambda$ to the first register producing the superposition
    \[ \frac{1}{\sqrt{\abs{G_\lambda}}} \sum_{g \in G_\lambda} \ket{g}\ket{x_\lambda}. \]
    Next, apply the unitary transformation $\ket{h}\ket{y} \mapsto \ket{h}\ket{h * y}$ to this state, followed by the quantum Fourier transform on the first register. This results in
    \[ \frac{1}{\abs{G_\lambda}} \sum_{h \in G_\lambda} \sum_{g \in G_\lambda} \chi(g, h) \ket{h}\ket{g * x_\lambda} = \frac{1}{\sqrt{\abs{G_\lambda}}} \sum_{h \in G_\lambda} \ket{h} \ket{G^{(h)} * x_\lambda} \]
    where $\ket{G^{(h)} * x_\lambda}$ is defined as in \eqref{eq:x-fourier-basis}. Measure the first register to obtain a random $h \in G_\lambda$, collapsing the state to $\ket{G^{(h)} * x_\lambda}$. Return the pair $(h, \ket{G^{(h)} * x_\lambda})$.

\item $\ver(h, \ket{\psi})$. First, check whether $\ket{\psi}$ has support in $X_\lambda$. If not, return $0$. Then, apply $\comph$ to the state $\ket{\psi}\ket{0}$, and measure the second register to obtain some $h' \in G_\lambda$. If $h' = h$, return $1$; otherwise return $0$.
\end{itemize}

From this point forward, to simplify the notation, we make the security parameter $\lambda$ implicit, and use $G$ for $G_\lambda$, $X$ for $X_\lambda$, and so on. 





\section*{Quantum Hartley Transform (QHT)}

The \textbf{Quantum Hartley Transform (QHT)} is a linear unitary transform that operates on quantum states. It transforms the basis states \( |x\rangle \) as follows:
\[
|x\rangle \xrightarrow{\text{QHT}} \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \text{cas}\left(\frac{2\pi x k}{N}\right) |k\rangle
\]
where:
\begin{itemize}
    \item \( x \) and \( k \) are integers in \( \{0, 1, \dots, N-1\} \),
    \item \( \text{cas}(x) = \cos(x) + \sin(x) \),
    \item \( N \) is the dimension of the transform, typically \( 2^n \) for \( n \)-qubit systems.
\end{itemize}

For a quantum state \( |\psi\rangle \) in an \( N \)-dimensional Hilbert space, represented as:
\[
|\psi\rangle = \sum_{x=0}^{N-1} \psi_x |x\rangle,
\]
the QHT transforms the state into:
\[
|\psi'\rangle = \text{QHT} |\psi\rangle = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \left( \sum_{x=0}^{N-1} \psi_x \, \text{cas}\left(\frac{2\pi x k}{N}\right) \right) |k\rangle.
\]

\subsection*{Properties of the QHT}
\begin{enumerate}
    \item \textbf{Unitary Transformation}: The QHT matrix \( U_{\text{QHT}} \) is unitary:
    \[
    U_{\text{QHT}} U_{\text{QHT}}^\dagger = I,
    \]
    preserving quantum state normalization.
    \item \textbf{Symmetry}: The QHT is symmetric because \( \text{cas}(x) = \text{cas}(-x) \).
    \item \textbf{Efficient Implementation}: Like the Quantum Fourier Transform (QFT), the QHT can be implemented with \( O(\log^2 N) \) gates for \( N = 2^n \).
\end{enumerate}

% \subsection*{Comparison with the Quantum Fourier Transform (QFT)}
% The QFT and QHT differ in their transformation kernels:
% \begin{itemize}
%     \item \textbf{QFT}:
%     \[
%     |x\rangle \xrightarrow{\text{QFT}} \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{2\pi i x k / N} |k\rangle.
%     \]
%     \item \textbf{QHT}:
%     \[
%     |x\rangle \xrightarrow{\text{QHT}} \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \left[\cos\left(\frac{2\pi x k}{N}\right) + \sin\left(\frac{2\pi x k}{N}\right)\right] |k\rangle.
%     \]
% \end{itemize}


\subsection*{Efficient implementation of Heartly transform}

********

\section{Quantum Money With The Hartley Transform}
\label{sec:qm_hartley}

The quantum money scheme above can be instantiated using the quantum Hartley transform instead of the quantum Fourier transform. However, this substitution breaks the verification algorithm. In the next sections, we will show how quantum walks can address this issue. To understand where the problem arises, we first present the $\gen$ and $\ver$ algorithms for the money scheme, similar to the previous description but with $\qht_G$ replacing $\qft_G$. For simplicity, we assume $G = \Z_N$. Let $x \in \Z_N$ be a fixed element.

\begin{itemize}
\item $\gen$. Begin with the state $\ket{0}\ket{x}$, and apply the quantum Hartley transform over $\Z_N$ to the first register producing the superposition
    \[ \frac{1}{\sqrt{N}} \sum_{g \in \Z_N} \ket{g}\ket{x}. \]
    Next, apply the unitary $\ket{h}\ket{y} \mapsto \ket{h}\ket{h * y}$ to this state, followed by a $\qht_N$ on the first register. This results in
    \[ \frac{1}{N} \sum_{h \in \Z_N} \sum_{g \in \Z_N} \cas\Big(\frac{2\pi gh}{N}\Big) \ket{h}\ket{g * x} = \frac{1}{\sqrt{N}} \sum_{h \in \Z_N} \ket{h} \ket{\Z_N^{(h)} * x}_H \]
    where
    \[ \ket{\Z_N^{(h)} * x}_H = \frac{1}{\sqrt{N}} \sum_{g \in \Z_N} \cas\Big(\frac{2\pi gh}{N}\Big) \ket{g * x}. \]
    Measure the first register to obtain a random $h \in \Z_N$, collapsing the state to $\ket{\Z_N^{(h)} * x}_H$. Return the pair $(h, \ket{\Z_N^{(h)} * x}_H)$.

\item $\ver(h, \ket{\psi})$. First, check whether $\ket{\psi}$ has support in $X$. If not, return $0$. Then, apply $\comph$ to the state $\ket{0} \ket{\psi}$, and measure the first register to obtain some $h' \in \Z_N$. If $h' = h$, return $1$; otherwise return $0$.
\end{itemize}

\section*{Verification using quantum walks}


\bibliographystyle{plain}
\bibliography{references}

\end{document}



