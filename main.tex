\documentclass[11pt]{article}


\usepackage[margin = 1in]{geometry}
\usepackage{article_macros}
\usepackage{authblk}
\usepackage{tikz}



\theoremstyle{definition}
\newtheorem{algorithm}{Algorithm}
\newtheorem{construction}[theorem]{Construction}

\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}

\newcommand{\cas}{\mathrm{cas}}
\newcommand{\cht}{\mathsf{H}}
\newcommand{\qht}{\mathsf{QHT}}
\newcommand{\cft}{\mathsf{F}}
\newcommand{\qft}{\mathsf{QFT}}
\newcommand{\comph}{\mathsf{cmpIndex}}
\newcommand{\gen}{\mathsf{Gen}}
\newcommand{\ver}{\mathsf{Ver}}








\title{Quantum Walks and Application to Quantum Money}

\author{Jake Doliskani\thanks{\tt jake.doliskani@mcmaster.ca} }
% \author{Morteza Mirzaei\thanks{\tt mirzam48@mcmaster.ca} }
\author{Seyed Ali Mousavi\thanks{\tt mousas26@mcmaster.ca} }
\affil{Department of Computing and Software, McMaster University}


\date{}
\sloppy
\allowdisplaybreaks










\begin{document}
\maketitle

\newpage
\section*{Abstract}

This thesis explores the foundations of quantum computation, focusing on quantum walks and their application to quantum money. Quantum walks, particularly continuous-time quantum walks based on group actions, serve as a powerful computational tool with applications in search algorithms and cryptographic protocols. We examine their mathematical structure and their advantages over classical random walks, emphasizing their efficiency in state evolution and probability distribution spreading. As a part of this work, we examine efficient implementations of transforms such as the Quantum Fourier Transform (QFT) and the Quantum Hartley Transform (QHT), analyzing their role in encoding quantum states for secure cryptographic applications. In particular, we discuss a novel instantiation of a quantum money scheme based on QHT, leveraging its unique properties for improved security and efficiency.
To ensure the robustness of this quantum money scheme, we develop a verification mechanism utilizing quantum walks. Unlike previous approaches, which rely on standard quantum state measurements, our method employs continuous-time quantum walks to authenticate quantum money, preventing counterfeiting while maintaining computational feasibility. Additionally, we present a detailed discussion on the efficient implementation of this scheme, including optimized circuit designs and error mitigation strategies.






\newpage
\section{Introduction to Quantum Computation}
\label{sec:intro}




\chapter{Introduction}
Quantum money, first introduced in a seminal paper by Wiesner [29], is a form of currency represented by quantum states. Unlike classical money, an ideal quantum bill cannot be counterfeited due to the no-cloning theorem of quantum mechanics, which prohibits making an identical copy of an unknown quantum state. Wiesner’s original scheme (now termed a \emph{private-key quantum money} scheme) had significant practical drawbacks: it required the issuing bank’s secret key to verify each banknote, meaning the bank had to be involved in every transaction. This reliance on the bank for verification severely limits the usability of private-key quantum money schemes.

In 2009, Aaronson [1] proposed the first \emph{public-key quantum money} scheme, in which anyone can verify a quantum banknote while only the bank can mint (issue) new valid banknotes. Public-key quantum money removes the transactional bottleneck of involving the bank every time. Aaronson’s specific scheme was later broken by Lutomirski et al.~[24]. In the years since, several alternative public-key quantum money constructions have been explored [2, 17, 30, 19, 20, 23, 31]. However, each of these proposals has either been broken by further cryptanalysis [14, 26, 7, 23] or relies on unconventional cryptographic assumptions, making their security or practicality questionable.

\medskip\noindent\textbf{Quantum Money from Group Actions and the Fourier Transform.} 
A promising candidate for secure public-key quantum money based on more standard assumptions was recently proposed by Zhandry [31]. In Zhandry’s scheme, the core idea is to use an abelian group action as the foundation for the quantum state. Each money state (quantum banknote) is prepared as a \emph{group-action Fourier state}, and the corresponding serial number is an element of the underlying group (we will elaborate on these terms in later chapters). The verification algorithm in this scheme uses a group-action phase kickback routine to extract the serial number from the quantum banknote and check its validity. Doliskani [15] later proved that Zhandry’s scheme is secure in the generic group action model, providing evidence for its security under well-defined assumptions.

\medskip\noindent\textbf{This Work – Motivation and Contributions.} 
In this thesis, we adapt Zhandry’s group-action quantum money scheme by replacing its use of the Quantum Fourier Transform with the \emph{Quantum Hartley Transform} (QHT) over finite abelian groups. The motivation behind this substitution is multifold. First, using the Hartley transform causes the banknotes to have \emph{real} amplitudes instead of complex amplitudes. We believe this shift from complex to real quantum states may offer both computational and theoretical advantages. For example, certain mathematical identities hold for any two real orthonormal bases that do not generally hold for complex bases; such differences can affect the properties of quantum states and were a barrier in prior analyses (indeed, an attempted “quantum lightning” construction in [31] failed due to properties of complex phases that do not arise with real amplitudes). Beyond this specific context, our work is a first step toward employing real-valued quantum transforms in quantum cryptography and quantum algorithms. To the best of our knowledge, this is the first significant quantum cryptographic construction that makes essential use of the quantum Hartley transform. We hope that exploring real-amplitude quantum states will inspire further research into new quantum algorithms and optimizations for real-valued transforms.

We now summarize our main contributions:
\begin{itemize}
    \item We propose a new \textbf{public-key quantum money scheme} based on abelian group actions and the quantum Hartley transform. This scheme is an adaptation of Zhandry’s group-action money scheme, modified to output real-amplitude quantum states. 
    \item We identify a breakdown in the original verification procedure when the Fourier transform is naively replaced by the Hartley transform: the Hartley-based verification fails to distinguish certain illegitimate banknotes. To overcome this, we design a \textbf{new verification algorithm} that relies on applying additional group action “twists” and utilizes quantum walks. This new verification algorithm successfully differentiates valid banknotes from forgeries despite the use of real amplitudes.
    \item We show that the serial number associated with a money state (which is a hidden group element) can be efficiently computed from the quantum state. In particular, we develop a \textbf{continuous-time quantum walk algorithm} to extract the serial number of a given banknote state. This algorithm leverages the structure of the group action and the spectral properties of an associated Cayley graph. Our method demonstrates that one can recover the hidden group element (serial) with high success probability, which not only underpins the new verification technique but is also of independent interest.
    \item In the course of our construction, we introduce a new algorithm for efficiently implementing the \textbf{quantum Hartley transform} and related real transforms. We present a recursive technique that exploits the structure of the Hartley transform, yielding a lower gate complexity than prior approaches in the literature. We also illustrate how other real-valued quantum transforms (e.g., the quantum sine transform) can be implemented using the Hartley transform as a subroutine. These results contribute to the broader goal of optimizing real quantum transforms for practical use.
\end{itemize}

In summary, our work combines ideas from quantum cryptography (public-key quantum money), quantum algorithms (quantum walks), and quantum signal processing (Hartley and related transforms) to create a novel and potentially practical quantum money scheme. 

\medskip\noindent\textbf{Thesis Organization.} 
The remainder of this thesis is organized as follows. In **Chapter 2**, we provide background on the basics of quantum computation and the theory of group actions, including the concept of cryptographic group actions which underlie our money scheme. **Chapter 3** covers quantum walks, both continuous-time and discrete-time, outlining their differences and importance in quantum algorithms. In **Chapter 4**, we apply the quantum walk framework to group actions: we describe how a continuous-time quantum walk on a group action can be simulated efficiently, a crucial step for our serial number extraction algorithm. **Chapter 5** details the quantum money scheme itself and the role of the Hartley transform in its construction. We explain how the scheme is formulated and discuss the advantages and challenges introduced by using the Hartley transform. Finally, **Chapter 6** presents the verification algorithm for the Hartley-based quantum money. This chapter shows how we use quantum walks (as developed in Chapter 4) to reliably verify banknotes and compute their serial numbers, thereby addressing the verification issues that arose from the use of real amplitudes.
\vspace{1em}






\chapter{Background on Quantum Computation and Group Actions}

\section{Quantum Computation Basics}
Quantum computation operates on information stored in quantum states. The fundamental unit of quantum information is the \emph{qubit}, which, unlike a classical bit, can exist in a superposition of basis states. A qubit is described by a state $|\psi\rangle = \alpha |0\rangle + \beta |1\rangle$ (in Dirac notation), where $\alpha,\beta \in \mathbb{C}$ and $|\alpha|^2 + |\beta|^2 = 1$. A system of $n$ qubits resides in a $2^n$-dimensional Hilbert space and its state can be a superposition of all $2^n$ basis basis states $|b_1b_2\cdots b_n\rangle$. 

Computation is carried out by unitary transformations on these states. A quantum algorithm is typically a sequence of quantum gates (unitary operators) applied to an initial state (usually a simple basis state like $|00\cdots0\rangle$), followed by a measurement of some qubits to obtain a classical result. A crucial aspect of quantum computation is that certain transformations—such as the Fourier transform over an $N$-element group—can be implemented very efficiently on a quantum computer (in $\operatorname{poly}(\log N)$ time), whereas their classical counterparts might require $\operatorname{poly}(N)$ time.

One example important to this work is the \textbf{quantum Fourier transform} (QFT). For an abelian group $G$ of order $N$, the QFT is the unitary map $|g\rangle \mapsto \frac{1}{\sqrt{N}}\sum_{h \in G} \chi_h(g)\, |h\rangle$, where $\{\chi_h\}$ are the characters (complex exponential homomorphisms) of $G$. In more familiar terms, when $G = \mathbb{Z}_N$ (the integers mod $N$), the QFT takes $|j\rangle$ to $\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1} e^{2\pi i j k / N} |k\rangle$. The QFT is a key component in many quantum algorithms, including Shor’s factoring algorithm and certain quantum money schemes (e.g., Zhandry’s) that rely on hiding information in phase relationships. The QFT can be implemented using $O((\log N)^2)$ basic gates for many groups [13], making it an efficient operation.

Another concept we will use is the \textbf{quantum Hartley transform} (QHT). The Hartley transform is an alternative to the Fourier transform that produces only real values (in the classical case) by using sinusoidal basis functions (sums of sine and cosine) instead of complex exponentials. The \emph{quantum} Hartley transform is the unitary transform corresponding to the classical Hartley transform. For example, the Hartley transform on $\mathbb{Z}_N$ maps a basis state $|j\rangle$ to $\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1} \mathrm{cas}\!\Big(\frac{2\pi j k}{N}\Big)\, |k\rangle$, where $\mathrm{cas}(x) = \cos x + \sin x$ is the Hartley kernel. Because $\cos x + \sin x$ is real for all $x$, the resulting amplitudes are real numbers. We will discuss the Hartley transform in more detail in Chapter 5, including how to implement it efficiently on a quantum computer.

A final fundamental principle to note is the \textbf{no-cloning theorem}, which underpins the security of quantum money. This theorem states that there is no physical operation that can make a copy of an arbitrary unknown quantum state. This contrasts sharply with classical information, which can be copied freely. The no-cloning theorem means that an adversary cannot duplicate a quantum banknote without fundamentally disturbing it – any attempt to “clone” the state will fail unless the adversary already has complete classical information describing that state.

Throughout this thesis, when we refer to an algorithm as \emph{efficient} or \emph{feasible}, we typically mean it can be performed by a quantum polynomial-time (QPT) algorithm. This is analogous to classical polynomial time, but on a quantum computer. All of the algorithms we propose (minting, verification, quantum walk simulation, etc.) are intended to be efficient in this sense.

\section{Group Actions in Cryptography}
At the heart of our quantum money scheme is the notion of a group action. A \textbf{group action} of a group $G$ on a set $X$ is a function $*\colon G \times X \to X$ that satisfies two properties: (1) the identity element $e \in G$ acts trivially on every $x \in X$ ($e * x = x$), and (2) the action is compatible with the group operation, meaning $g*(h* x) = (gh)*x$ for all $g,h \in G$ and $x \in X$. We will often denote the result of $g$ acting on $x$ by $g*x$ or simply $g x$ when the action is clear from context.

The orbit of an element $x \in X$ under the action is the set $G * x = \{g*x : g \in G\} \subseteq X$. If there is exactly one orbit (i.e., $G * x = X$ for some $x$), the action is called \emph{transitive}. If, in addition, no non-identity group element fixes any $x$ (i.e., $g * x = x$ implies $g = e$), then the action is \emph{free}. A group action that is both transitive and free is sometimes called a \textbf{regular action}. In a regular action, for any two elements $y, z \in X$, there is a unique group element $g$ such that $g * y = z$. In other words, $G$ acts like a permutation group that moves elements of $X$ around, and knowing the starting and ending point uniquely determines the “move” $g$. In this case $|X| = |G|$, and we can think of $X$ as essentially a copy of $G$ with the group structure “hidden” by the action.

Group actions are ubiquitous in modern cryptography. A \textbf{cryptographic group action} is one where the action is easy to compute in the forward direction, but inverting the action (recovering $g$ from $x$ and $g*x$) is computationally hard. This essentially functions as a one-way function: given $x$ and $g$, it is easy to compute $y = g*x$, but given $x$ and $y$ it is infeasible to find $g$ (except with negligible probability). One classical example is the discrete logarithm problem: consider the cyclic group $G = \mathbb{Z}_p^*$ (the multiplicative group of a prime field) acting on itself by exponentiation. Let $X = G$ and define $g * x = x^g \pmod p$ (treating group elements as integers). Here $g$ is an exponent. This is a group action (in fact, just the group’s own operation written differently), and computing $x^g \bmod p$ is efficient. However, given $x$ and $y = x^g$, finding $g$ requires solving a discrete log problem, which is believed to be hard for suitable choices of $p$. Thus, exponentiation can be viewed as a one-way group action.

Another prominent example comes from elliptic-curve cryptography: the action of an ideal class group on a set of elliptic curves. In schemes like CSIDH (Commutative Supersingular Isogeny Diffie–Hellman), an abelian group of ideal classes $G$ acts on the set $X$ of supersingular elliptic curves by isogeny (an isogeny is a structure-preserving map between curves). Starting from a curve $x_0$, one can efficiently compute $g * x_0$ (which is another elliptic curve) for any group element $g$, but given two curves $x_0$ and $x = g * x_0$, it is believed to be computationally hard to recover $g$. This hard problem is the foundation of isogeny-based cryptography. We refer to such $G$ and $X$ as a \emph{cryptographic group action} pair.

Cryptographic group actions provide a natural platform for public-key quantum money schemes. In such schemes, the secret “serial number” of a quantum banknote can be an element $g \in G$, and the quantum state of the banknote can be some function of $g*x_0$ for a public base point $x_0 \in X$. The hardness of inverting the action ($x_0$ and $x = g*x_0$ do not easily reveal $g$) contributes to the security against counterfeiting, while the structure of the group action can be used to efficiently verify authenticity (as we will see with the Fourier or Hartley transform techniques).

We will assume throughout that we have a family of abelian group actions $(G,X)$ that are cryptographically suitable: $|G|$ is large (growing with the security parameter), the action is efficiently computable, transitive and free (so $|X|=|G|$), and inverting the action is infeasible without the secret key. Such families are conjectured to exist (for example, the isogeny-based actions, and others discussed in cryptographic literature). 

Finally, we note that working in the \textbf{generic group model} (or generic group \emph{action} model) is a common theoretical approach to analyze security. In a generic model, the group elements are treated as black-box labels without exploiting any special algebraic structure beyond group axioms. Doliskani’s proof of security for Zhandry’s scheme [15] was in such a generic model for group actions, lending confidence that no “generic” attack can break the scheme. In this thesis, we focus on designing the scheme and algorithms at a high level and assume the underlying group action is secure; a detailed security proof is beyond our scope, though we rely on prior results for reassurance.

\chapter{Quantum Walks – Continuous and Discrete}
Random walks on graphs are a powerful tool in classical algorithms, and their quantum analogues, called \emph{quantum walks}, play a fundamental role in many quantum algorithms. Like classical random walks, quantum walks come in two flavors: \textbf{continuous-time} and \textbf{discrete-time}. Both types of quantum walks can exhibit dramatically different behavior from their classical counterparts due to quantum interference, which can be leveraged for algorithmic speedups in various problems (for example, quantum walks have led to faster algorithms for database search and element distinctness [4, 5], as well as exponential speedups in oracular problems [10]).

\section{Continuous-Time Quantum Walks}
A continuous-time quantum walk (CTQW) takes place on the vertices of a graph and is defined by a Hamiltonian (energy operator) that drives the evolution of a quantum state across the graph. Formally, consider a graph $\Gamma$ with vertex set $V$ of size $n$. We associate a basis state $|v\rangle$ with each vertex $v \in V$. In a continuous-time \emph{classical} random walk, one can describe the probability distribution $p(t)$ over vertices at time $t$ by a differential equation $dp/dt = -L p(t)$, where $L$ is the Laplacian matrix of the graph. By analogy, in a continuous-time \emph{quantum} walk, we use the Schrödinger equation:
\[ i\,\frac{d}{dt}|\psi(t)\rangle = H\,|\psi(t)\rangle, \] 
where $H$ is the Hamiltonian of the walk and $|\psi(t)\rangle$ is the state of the quantum walk at time $t$. The formal solution is $|\psi(t)\rangle = e^{-i H t} |\psi(0)\rangle$. Intuitively, $H$ encodes the connectivity of the graph, and the quantum state evolves continuously, “exploring” the graph’s vertices.

Typically, for a quantum walk on an undirected graph, a natural choice of Hamiltonian $H$ is the adjacency matrix of the graph (sometimes the Laplacian or a normalized version is used, but the adjacency matrix suffices for our purposes). If $A$ is the adjacency matrix of $\Gamma$, then $H = A$ means that the amplitudes flow between adjacent vertices over time. Specifically, if $|v\rangle$ and $|w\rangle$ are connected by an edge, the Hamiltonian will induce oscillations of amplitude between $|v\rangle$ and $|w\rangle$. Because $H$ is Hermitian, $e^{-iA t}$ is unitary, ensuring the evolution is coherent.

One notable feature of CTQWs is that interference effects can cause the walker to propagate through the graph in ways that a classical random walk cannot. For example, quantum walkers can have ballistic spreading (moving roughly linearly fast with time) on certain graphs, whereas classical diffusion is much slower (like $\sqrt{t}$ spread). These effects underlie algorithmic speedups. For instance, the continuous-time walk on a certain $N$-vertex graph can reach a target vertex in $O(N^{1/2})$ time, whereas a classical random walk might take $O(N)$ steps to achieve the same, illustrating a quadratic speedup in some search problems.

\section{Discrete-Time Quantum Walks}
Discrete-time quantum walks proceed in a sequence of steps rather than evolving continuously. In the discrete-time case, we typically require an additional “coin” space or a similar construction to allow the walker to move without violating unitarity (since a deterministic move on an undirected graph can lead to stagnation without a coin toss to break symmetry). In the \textbf{coined model} of a quantum walk, the state is a tensor product $|\text{position}\rangle \otimes |\text{coin}\rangle$. At each step, a unitary coin flip (like a Hadamard gate generalizing a two-sided coin to a multi-sided one for vertices of higher degree) is applied to the coin register, and then a conditional shift moves the walker to a new vertex based on the coin outcome. This two-part operation (coin flip + shift) constitutes one step of the walk, which is a unitary transformation on the overall Hilbert space.

There is also an alternative approach to discrete-time walks that does not explicitly use a coin, but instead doubles the state space in another way. One such approach, due to Szegedy [27], represents a step as two reflections on an enlarged Hilbert space associated with the edges of the graph. Another approach (used in some of our analysis) constructs a discrete-time walk using the graph’s adjacency matrix but treats it in a quantum way. For a graph $\Gamma=(V,E)$, one can define a unitary operator $U$ acting on the space spanned by $\{|v\rangle \otimes |0/1\rangle: v \in V\}$ (position plus one qubit) that effectively simulates moving along the edges. For example, one can design $U$ such that:
\[ U:\; |v,0\rangle \mapsto \frac{1}{\sqrt{\deg(v)}}\sum_{(v\to w)\in E} |w,1\rangle, \] 
and similarly $|w,1\rangle$ moves back to $|v,0\rangle$ on the reverse edge. This “flip-flop” shift is one way to implement a discrete quantum walk step. In essence, the walker has a direction bit that flips each time an edge is traversed, preventing it from just oscillating back and forth between two vertices. After many such steps, the probability amplitude distribution over $V$ can spread across the graph.

Despite the differences in formulation, continuous- and discrete-time quantum walks are closely related. In fact, it has been shown by Childs [9] and by Berry, Childs, and Kothari [6] that a continuous-time quantum walk can be efficiently simulated using a discrete-time quantum walk. The key idea is to approximate the continuous evolution $e^{-iAt}$ by a product of many short discrete updates (Trotterization or a related technique). More concretely, given a Hamiltonian $H$ driving a CTQW, one can introduce an ancillary system and a carefully constructed unitary such that the effect of $e^{-iHt}$ is approximated to arbitrary precision with a polynomial number of discrete steps. This means that any algorithm that could be conceived in the continuous-time framework can be translated to a discrete-time circuit model with only polylogarithmic overhead in complexity (assuming $H$ is sparse, which in our cases it will be).

Quantum walks have been employed in a range of quantum algorithms. For example, Ambainis’s algorithm for element distinctness [5] uses a discrete-time quantum walk on the Johnson graph to achieve a faster than brute-force runtime. Childs et al. demonstrated an exponential separation between quantum and classical query complexities using a continuous-time quantum walk in a contrived maze problem [10]. Many search and optimization problems have also been tackled with quantum walk algorithms. The common theme is that quantum interference allows the walk to navigate the solution space more efficiently than random fluctuation alone.

In the remainder of this thesis, we will use whichever model of quantum walk is most convenient for analysis. Our verification algorithm in Chapter 6 will be described conceptually as a continuous-time walk (because it naturally fits the problem structure), but behind the scenes we will implement it using a discrete-time simulation (Chapter 4 will provide details on how this simulation is done for our specific application). 

\chapter{Simulating Group Action Quantum Walks}
In this chapter, we bridge the concepts from Chapter 2 (group actions) and Chapter 3 (quantum walks). Specifically, we consider quantum walks on graphs that arise from group actions, and we discuss how to implement or simulate such walks efficiently on a quantum computer. This is crucial for our quantum money verification algorithm, which will require running a quantum walk on a graph defined by the given group action.

\section{Cayley Graphs of Groups and Group Actions}
A convenient way to visualize a group or a group action is via its Cayley graph. First, for an ordinary (abelian) group $G$, if we pick a generating set $S \subset G$ (for example, $S$ could be a small symmetric set of generators such that every element of $G$ can be expressed as a product of elements in $S$), the \textbf{Cayley graph} $\Gamma(G,S)$ is an undirected graph defined as follows: each group element $g \in G$ corresponds to a vertex, and there is an edge between $g$ and $h$ if and only if $h = s \cdot g$ for some generator $s \in S$ (equivalently $g$ and $h$ differ by multiplication by a generator). We typically take $S$ to be symmetric (if $s \in S$ then $s^{-1} \in S$) so that the resulting graph is undirected. The Cayley graph encapsulates the structure of the group in graph form.

The adjacency matrix $A$ of $\Gamma(G,S)$ has rows and columns indexed by $G$, and $(A)_{g,h} = 1$ if $h = s\cdot g$ for some $s \in S$, and $0$ otherwise. It is known that for a finite abelian group $G$, the eigenvectors of this adjacency matrix are related to the characters of $G$ (essentially the Fourier basis on the group), and the eigenvalues can be determined from $S$. In particular, if $\chi: G \to \mathbb{C}$ is a character (one of the Fourier basis functions), then it is an eigenvector of $A$. The corresponding eigenvalue is $\lambda_{\chi} = \sum_{s\in S} \chi(s)$ (the character evaluated on each generator and summed). This means the QFT over $G$ diagonalizes the adjacency matrix $A$. As a result, a continuous-time quantum walk on $\Gamma(G,S)$ can be solved analytically by moving to the Fourier basis: $e^{-iAt}$ acts by phases $e^{-i\lambda_{\chi} t}$ on each Fourier basis state. Moreover, if $S$ is small (say $|S| = \operatorname{poly}(\log |G|)$), one can efficiently implement $e^{-iAt}$ using the QFT: prepare the state in the Fourier basis (apply QFT), apply a phase rotation by $\lambda_{\chi} t$ on each basis state (which can be done classically if we can compute $\lambda_{\chi}$), and then inverse QFT. This takes polynomial time in the size of the problem parameters. (For example, for $G=\mathbb{Z}_N$, this procedure would simulate the continuous-time walk by using two QFTs of size $N$ and a linear-time classical phase rotation on $N$ amplitudes, which is efficient.)

Now, consider a group action $G \curvearrowright X$ where $X$ is a set on which $G$ acts. We can similarly define a Cayley-type graph for the action. Fix a particular element $x_0 \in X$ as a basepoint. Take the same generating set $S \subset G$. We define the \textbf{group action graph} $\Gamma(X,S)$ as the graph whose vertex set is $X$, and put an edge between two vertices $x, y \in X$ if and only if there exists $s \in S$ such that $y = s * x$ (i.e., $y$ is the result of the group element $s$ acting on $x$). Because $S$ is symmetric and the action is regular (in our applications), this graph is also undirected and regular. Essentially, $\Gamma(X,S)$ is the “projection” of the group’s Cayley graph into the set $X$ via the action.

If the action of $G$ on $X$ is regular, $\Gamma(X,S)$ is isomorphic to $\Gamma(G,S)$ as an abstract graph (they are structurally the same graph, just the labels of vertices are different: one uses group elements $g$, the other uses states $x = g*x_0$). However, there is an important distinction from a computational perspective: labeling the vertices by elements of $X$ might conceal the group structure. In fact, if the group action is cryptographically one-way, then although there is a one-to-one correspondence between $G$ and $X$ (via $g \leftrightarrow g* x_0$), finding the group element label $g$ corresponding to a given $x \in X$ is hard. In other words, we (as algorithm designers) can efficiently enumerate and work with the group element labels $g \in G$, but an algorithm working with the $X$-labels may not be able to perform the same tasks, because moving to the $G$ label requires inverting the group action.

To put it another way: mathematically, $A(G,S)$ and $A(X,S)$ (the adjacency matrices of the two Cayley graphs) are related by a permutation of the basis if we know the isomorphism $X \cong G$. If we had an oracle giving us $g$ for each $x = g*x_0$, then $A(X,S)$ could be efficiently diagonalized just as $A(G,S)$ is (by switching to group element labels and applying QFT). But under cryptographic assumptions, we do not have such an oracle; effectively, the basis $\{|x\rangle: x \in X\}$ is a “hidden permutation” of the nice Fourier basis. This means that direct quantum Fourier techniques cannot be applied to $A(X,S)$, and new techniques are required to simulate a quantum walk on $\Gamma(X,S)$.

Nonetheless, all is not lost. Even if we cannot diagonalize $A(X,S)$ explicitly, we can still leverage the fact that $A(X,S)$ is sparse and structured. The degree of each vertex in $\Gamma(X,S)$ is $|S|$, which by assumption is small (at most polynomial in $\log |G|$ for efficiency). This sparsity allows us to implement the quantum walk step by step, as we will outline below. Moreover, as observed in prior works, even cryptographic group action graphs can sometimes be navigated quantumly. For instance, continuous-time quantum walks have been studied in the context of isogeny-based group actions (supersingular isogeny graphs) [8, 16]. These works implement quantum walks on those graphs (typically for solving certain problems or analyzing mixing properties), treating the action oracle as a black box. We will adopt a similar approach: we assume we have efficient oracles for the group action (given $g$ and $x$, compute $g*x$) and for checking group membership or identity if needed. Under this assumption, we can implement the quantum walk unitaries directly on the $X$-labeled state space.

\section{Efficient Simulation of Continuous-Time Walks via Discrete Steps}
As mentioned in Chapter 3, any continuous-time quantum walk on a sparse Hamiltonian can be simulated with a sequence of discrete-time operations. In the context of the group action Cayley graph $\Gamma(X,S)$, we want to simulate the unitary $U(t) = e^{-i A(X,S) t}$ for some time $t$ (or a sequence of such unitaries for various times). Thanks to Childs [9] and Berry–Childs–Kothari [6], we know that $U(t)$ can be approximated to high precision with $O(\|A\|_{\max} t\, \operatorname{poly}(1/\epsilon))$ uses of a discrete-time walk step and additional gates, where $\epsilon$ is the desired error and $\|A\|_{\max}$ is related to the maximum degree (here $\|A\|_{\max} = |S|$). In our case, $|S|$ is small, and $t$ will also be bounded by a polynomial in the relevant input size (for instance, in our application $t$ will be related to the inverse spectral gap or some parameter of the walk, but we will choose manageable values). Therefore, an efficient simulation means we need to implement a single step of the discrete-time quantum walk efficiently. We now describe how to implement the core components of a discrete-time walk on $\Gamma(X,S)$.

Following the approach used in [6, 9], the key components are:
1. An \textbf{oracle for the sparse Hamiltonian} (in this case, the adjacency matrix). This oracle, given a vertex label and an index, outputs the neighboring vertex corresponding to that index. For $\Gamma(X,S)$, since each vertex $x$ has $|S|$ neighbors (one for each $s \in S$), such an oracle would on input $(x, j)$ (with $j \in \{1,\dots,|S|\}$ indexing the generators in $S$) output the neighbor $y = s_j * x$. We can implement this “oracle” explicitly because we can compute the group action: we know each generator $s_j$, so we can map $(x, j) \mapsto s_j * x$ by a single group action computation. This is a classical operation performed quantumly (i.e., we can build a unitary that performs $|x\rangle|j\rangle \mapsto |x\rangle |y\rangle$ where $y = s_j * x$).
2. Construction of the \textbf{isometry} $V$ that prepares a superposition of neighbor states. Specifically, for each vertex $x$, we want:
\[ V:\; |x\rangle \;\mapsto\; \frac{1}{\sqrt{|S|}} \sum_{s \in S} |x, s* x\rangle, \] 
where we have used an output register to hold the neighbor. This isometry $V$ can be implemented by first adding an ancilla register for the group element in $S$, initializing it to $|0\rangle$, then creating an equal superposition over all $s \in S$ in that register, and finally replacing that register’s value with the resulting neighbor. Concretely, start with $|x, 0\rangle$. Use a unitary $U_S$ on the second register such that $U_S|0\rangle = \frac{1}{\sqrt{|S|}}\sum_{s\in S} |s\rangle$. Now the state is $\frac{1}{\sqrt{|S|}}\sum_{s\in S} |x, s\rangle$. Next, apply the group action oracle to compute $s * x$ in a third register (or overwrite the first register), obtaining $\frac{1}{\sqrt{|S|}}\sum_{s} |x, s, s*x\rangle$. Then “uncompute” the $s$ register (apply $U_S^\dagger$ to bring it back to $|0\rangle$) so that we end with $\frac{1}{\sqrt{|S|}}\sum_{s} |x, s*x\rangle$. Rename the two registers as $|x\rangle_{\text{orig}} |y\rangle_{\text{nbr}}$. This is exactly the desired $V|x\rangle = \frac{1}{\sqrt{|S|}}\sum_{y:\,y = s*x} |x, y\rangle$. We have thus implemented $V$ by using the ability to iterate over all generators (which is feasible since $|S|$ is small) and the group action operation.

3. We also need to implement $V^\dagger$ (the inverse isometry) which, given a superposition of $|x,y\rangle$, reverses the above process and yields $|x\rangle$ (provided $y$ was indeed one of the neighbors of $x$ in the superposition). This essentially requires an operation to compute $s$ from $(x,y)$ such that $y=s*x$. Since the action is free and $S$ is small, we can find which generator maps $x$ to $y$ by checking each $s \in S$ (this is a small brute-force check done coherently). We can implement a unitary that, for each pair $(x,y)$, finds the unique $s$ with $y=s*x$ and writes $s$ in an ancilla (using comparisons), then uncompute the $y$ register by applying $s^{-1}$ to $y$ (which returns it to $x$) while also un-entangling the $s$. In practice, this is efficient since $|S|$ is small and trying all $s$ is a constant or polynomial-time classical loop. We assume an oracle or routine that can perform this inversion on a case-by-case basis.

4. The final component is the \textbf{reflection operator} (or the walk step) that uses $V$ and $V^\dagger$. In the continuous-to-discrete simulation algorithm, one defines a reflection $R = 2V V^\dagger - I$. $R$ acts on the enlarged space of vertex-neighbor pairs, and it essentially flips the phase of any state orthogonal to the subspace $\{\frac{1}{\sqrt{|S|}}\sum_{s}|x,s*x\rangle: x \in X\}$ prepared by $V$. Intuitively, $R$ distinguishes states that are “properly correlated” as in a single step of a walk from those that are not, and flips the latter’s sign. The crucial point is that if we can implement $V$ efficiently (and $V^\dagger$ accordingly) and also trivial reflections like $|0\rangle \to -|0\rangle$ on ancilla states, then we can implement $R$ efficiently as well (since $R = V (2|0\rangle\!\langle 0| - I) V^\dagger$, which means perform $V^\dagger$, do a phase flip on the $|0\rangle$ state of the ancillary superposition register, then apply $V$).

Given these components, a single discrete-time quantum walk step $U_{\text{walk}}$ on $\Gamma(X,S)$ can be constructed. In many formulations, one actually uses two reflections to form the walk operator: one as above and another to reflect about the starting subspace (ensuring the walk doesn’t have trivial stationary components). However, in the Childs–Berry–Kothari simulation approach, the walk operator is taken as $W = (2V V^\dagger - I) \cdot ( \text{swap registers} )$. The “swap” simply swaps the two registers $|x,y\rangle \mapsto |y,x\rangle$, causing a move from $(\text{orig}, \text{nbr})$ to $(\text{new orig} = \text{old nbr}, \text{new nbr} = \text{old orig})$. This swap combined with $R$ effectively implements the adjacency relationships as a unitary walk.

To summarize, we have outlined how:
- The isometry $V$ and its inverse can be implemented with a polynomial number of operations (scaling with $|S|$ and the cost of computing the group action).
- The reflection $R$ can be built from $V$ and a simple phase flip.
- The swap operation on two registers is straightforward.

Thus, all components of the discrete-time quantum walk step on the group action graph are efficient. We can now leverage known results to claim that a continuous-time walk generated by the Hamiltonian $A(X,S)$ for time $t$ can be simulated by applying $O(t\,\operatorname{poly}(|S|))$ steps of the above discrete walk $W$. In our context, we will not need $t$ to be extremely large; we will be interested in running phase estimation on $e^{-iA t}$ for some moderate $t$ values. The efficiency we have established means this phase estimation will be feasible.

\section{Group Action Quantum Walks and Spectral Properties}
Before moving on, it is worth discussing what the spectral properties of the group action Cayley graph $A(X,S)$ imply for our algorithm (which will come in Chapter 6). We have noted that in the absence of one-wayness, the eigenstates of $A(X,S)$ would be known (Fourier states) with eigenvalues $\lambda_{\chi} = \sum_{s\in S} \chi(s)$. In the presence of one-wayness, we cannot directly label those eigenstates, but they still exist. In particular, if $G$ is abelian, the adjacency matrix $A(X,S)$ will have the same multiset of eigenvalues as $A(G,S)$. Let us denote those eigenvalues by $\{\lambda_k: k=1,\dots,|G|\}$. We may not know which eigenvalue corresponds to which state in $X$, but we know each $\lambda_k = \sum_{s\in S} \chi_k(s)$ for some character $\chi_k$ of $G$. For example, in a simple case $G = \mathbb{Z}_N$ and $S=\{1, -1\}$, the eigenvalues of $A(G,S)$ (and thus $A(X,S)$) would be $2\cos(2\pi k/N)$ for $k=0,\dots,N-1$. The important take-away is that the eigenvalues are related to the group structure (often involving cosine terms if $S$ is symmetric), and the eigenvectors are “global” states spread out over the vertices.

In the next chapter, we will construct our quantum money scheme such that a valid banknote state is one of these eigenvectors (or closely related to an eigenvector) of a certain group action graph. This will be by design: when minting money, the procedure will create a state that, under the action of the adjacency matrix of $\Gamma(X,S)$, picks up a well-defined phase. In Chapter 6, our verification algorithm will leverage this by using phase estimation on the continuous-time walk unitary $e^{-iA t}$ to determine the eigenvalue (and thereby infer the “serial number” hidden in the state).

Having established that we can perform the quantum walk on $\Gamma(X,S)$ efficiently, we are prepared to move on to the construction of the quantum money scheme itself, and then to the details of the verification algorithm that uses these walks.

\chapter{Quantum Money and the Hartley Transform}
We now present our public-key quantum money scheme based on group actions and the Hartley transform. We begin by reviewing Zhandry’s quantum money scheme from abelian group actions (which uses the Fourier transform) as a baseline. Then we describe our Hartley-transform-based variant and discuss its properties. The quantum Hartley transform will play a central role in both the minting and verification of banknotes.

\section{Public-Key Quantum Money: Definitions}
A public-key quantum money scheme consists of two algorithms, traditionally called $\mathsf{Mint}$ and $\mathsf{Verify}$:
\begin{itemize}
    \item $\mathsf{Mint}(1^n)$ is a probabilistic quantum polynomial-time (QPT) algorithm that, given a security parameter $n$, outputs a pair $(s, |\$\rangle)$. Here $s$ is a classical string called the \emph{serial number} (or public key) and $|\$\rangle$ is a quantum state representing the banknote. We often call the pair $(s, |\$\rangle)$ a banknote, and $s$ by itself the serial number of that banknote.
    \item $\mathsf{Verify}(s, |\$\rangle)$ is a QPT algorithm (which may be implemented as a quantum circuit acting on the state $|\$\rangle$ and some ancillary workspace). It takes as input a serial number $s$ and an alleged quantum banknote state $|\$\rangle$. It outputs $\mathtt{accept}$ (valid) or $\mathtt{reject}$ (invalid).
\end{itemize}

We require two properties from such a scheme:
\begin{description}
    \item[Correctness:] For any valid output $(s, |\$\rangle)$ of $\mathsf{Mint}(1^n)$, the verification algorithm accepts with high probability. Formally, $\Pr[\mathsf{Verify}(s, |\$\rangle) = \mathtt{accept}]$ should be very close to 1 (typically we require it to be $1 - \negl(n)$, where $\negl(n)$ denotes a negligible function in $n$).
    \item[Security (Unforgeability):] No efficient adversary, given one or more genuine banknotes, can produce a new valid banknote. In the strongest formulation, if an adversary is given a single valid $(s, |\$\rangle)$, it should be infeasible for them to produce two quantum states $|\$'\rangle$ and $|\$''\rangle$ such that $\mathsf{Verify}(s, |\$'\rangle) = \mathsf{Verify}(s, |\$''\rangle) = \mathtt{accept}$ (i.e., they cannot create a second copy that passes verification while retaining the original). More generally, even given multiple banknotes, the adversary should not be able to create new ones with fresh serial numbers that pass verification. This captures the idea that quantum money cannot be counterfeited.
\end{description}

In a \emph{public-key} scheme, the verifier uses only the public information (here, the serial number and any scheme-wide public parameters) to check validity, and does not need any secret key. The bank (mint) may have a secret key to produce the states, but after minting, the bank’s involvement is not needed. In our scheme, the serial number will effectively contain the information needed for public verification (similar to how a classical bill might have a number anyone can look up, except here it’s used in a quantum procedure).

We next outline Zhandry’s scheme, which our scheme builds upon.

\section{Fourier-Based Quantum Money from Group Actions}
Zhandry’s quantum money scheme [31] is built on an abelian group action $G \curvearrowright X$. We have a family of group actions parameterized by the security parameter $n$ (so the size of $G$ grows with $n$). For simplicity, assume $|G| = N$. The scheme also fixes a particular element $x_0 \in X$ that everyone knows (a public base point in $X$).

The minting algorithm $\mathsf{Mint}$ in Zhandry’s scheme works as follows (informally):
\begin{enumerate}
    \item On input $1^n$, sample a random group element $g \leftarrow G$. This $g$ will serve as the serial number $s$ for the banknote.
    \item Prepare two registers: the first is a group element register, initialized to $|0_G\rangle$ (an encoding of the identity element of $G$), and the second is an $X$-register initialized to $|x_0\rangle$.
    \item Apply the quantum Fourier transform over $G$ to the first register. This creates a uniform superposition over $G$: 
    \[
    \frac{1}{\sqrt{N}} \sum_{h \in G} |h\rangle \otimes |x_0\rangle\,.
    \] 
    \item Now apply the group action in a controlled manner: for each basis state $|h\rangle$ in the first register, apply $h$’s action on the second register. This transforms the joint state into 
    \[
    \frac{1}{\sqrt{N}} \sum_{h \in G} |h\rangle \otimes |h * x_0\rangle\,,
    \] 
    which is an entangled state between a superposition of group elements and their corresponding $X$-elements.
    \item Apply the inverse QFT (which is the adjoint of the QFT) on the first register. This recombines the amplitudes in the first register. The result (by properties of the QFT) can be shown to be 
    \[
    \frac{1}{\sqrt{N}} \sum_{h \in G} \omega^{\langle g,\,h \rangle} |h\rangle \otimes |h * x_0\rangle\,,
    \] 
    where $\omega^{\langle g,\,h \rangle}$ denotes the phase picked up that depends on $g$ and $h$. In fact, this state can be written as $|g\rangle \otimes \frac{1}{\sqrt{N}}\sum_{h \in G} |h * x_0\rangle$; essentially, the first register ends up in $|g\rangle$ (the serial number) and the second register is an equal superposition of all elements of $X$ in the orbit of $x_0$ (which is $X$ itself, since the action is transitive) but weighted by a phase related to $g$. This is the so-called group-action Fourier state.
    \item The first register (which contains $|g\rangle$) is measured in the computational basis, yielding the random serial number $g$ and collapsing the second register to a state that we will denote $|\$_g\rangle$. This $|\$_g\rangle$ is the actual quantum money state corresponding to serial $g$.
    \item Output the pair $(s = g,\; |\$\rangle = |\$_g\rangle)$.
\end{enumerate}

In the above, a bit of algebra reveals that $|\$_g\rangle = \frac{1}{\sqrt{N}} \sum_{h \in G} \chi_g(h)\, |h * x_0\rangle$, where $\chi_g(h) = \omega^{\langle g,\,h \rangle}$ is essentially the character of $G$ indexed by $g$. In other words, $|\$_g\rangle$ is (up to global phase) the state one gets by applying the representation (character) $\chi_g$ to weight the superposition over the orbit $X$. These states for different $g$ are almost orthogonal and can be distinguished with the right measurement.

The verification algorithm $\mathsf{Verify}(g, |\$_g\rangle)$ for Zhandry’s scheme goes as follows:
\begin{enumerate}
    \item Given the purported serial number $g \in G$ and an input state $|\psi\rangle$ (which should equal $|\$_g\rangle$ if genuine), attach an auxiliary register prepared in $|x_0\rangle$.
    \item Perform a controlled group action “kickback” using $g$ on the auxiliary register. Specifically, perform the unitary that maps $|y\rangle \otimes |x_0\rangle \mapsto |y\rangle \otimes |g * x_0 \rangle$ for each basis element $|y\rangle$ of the first register. (This operation uses the classical $g$ to act on the second register conditioned on the first—essentially, it multiplies the second register’s state by $g$ if the first register is in an appropriate basis state. There are various ways to implement this, but conceptually it’s a controlled operation using the known $g$.)
    \item Now measure the second register (the auxiliary one) in the computational basis of $X$ to see if it is still $|x_0\rangle$. If the state $|\psi\rangle$ was the correct Fourier state $|\$_g\rangle$, one can show that this measurement will yield $x_0$ with high probability (constructive interference causes the $x_0$ component to be strong). If $|\psi\rangle$ was not the correct state, the measurement is unlikely to give $x_0$.
    \item Accept if and only if the measurement outcome is $x_0$ (i.e. the second register returns to the base state).
\end{enumerate}

The intuition is that the genuine state $|\$_g\rangle$ contains a phase that exactly cancels out the action of $g$ in the verification step, causing the auxiliary register to end up back at $x_0$. A counterfeit state, by contrast, would not generally have the right phase relationship, and the auxiliary register’s state would be some superposition over $X$ that is not concentrated on $x_0$, hence likely giving a different outcome upon measurement.

Zhandry’s scheme is shown to be correct (valid notes pass) and is believed to be secure under the assumption that the group action is one-way. The hardness essentially boils down to: given $x_0$ and $|\$_g\rangle$, an adversary cannot figure out a different $g'$ that would produce a second valid state $|\$_{g'}\rangle$ or replicate $|\$_g\rangle$ (because that would solve the hidden subgroup or discrete log type problem in the group action).

\section{Hartley-Transform Money Scheme Construction}
Our scheme modifies the above Fourier-based construction by utilizing the \textbf{quantum Hartley transform (QHT)} in place of the QFT. Since the Hartley transform is closely related to the Fourier transform (essentially it produces the real and imaginary parts in a single real-valued transform), one might expect this substitution to be straightforward. And indeed, for the minting procedure it largely is: we will use the QHT to create real-amplitude superposition states.

Concretely, assume again a group action $G \curvearrowright X$ with $|G|=N$. We fix the same generating set $S$ and basepoint $x_0$. The $\mathsf{Mint}_{H}$ (Hartley mint) algorithm:
\begin{enumerate}
    \item Sample a random $g \leftarrow G$ to be the serial number.
    \item Prepare $|0_G, x_0\rangle$ as before.
    \item Apply the \emph{quantum Hartley transform} over $G$ to the first register. The Hartley transform (on an abelian group of order $N$) is defined as:
    \[
       \mathrm{QHT}: |h\rangle \mapsto \frac{1}{\sqrt{N}} \sum_{k \in G} \cas\!\Big(\frac{2\pi \langle k,h \rangle}{N}\Big) |k\rangle,
    \] 
    where $\mathrm{cas}(\theta) = \cos \theta + \sin \theta$ and $\langle k,h \rangle$ denotes some pairing like an exponent or dot product (for cyclic groups this is just $kh$). In simpler terms, $\mathrm{QHT}(|0_G\rangle) = \frac{1}{\sqrt{N}}\sum_{k \in G} |k\rangle$ (because $\cas(0)=1$), \emph{the same uniform superposition as the QFT produces for $|0\rangle$}. So after this step, we again have $\frac{1}{\sqrt{N}}\sum_{h \in G} |h\rangle|x_0\rangle$, but crucially the coefficients are all \emph{real} and positive (in fact all $1/\sqrt{N}$).
    \item Perform the controlled group action by the first register on the second: $\frac{1}{\sqrt{N}}\sum_{h} |h\rangle |h*x_0\rangle$.
    \item Apply the inverse QHT on the first register (which being its own inverse up to a constant factor, is the same operation again since Hartley is symmetric like Fourier). Now here is where things differ: after this operation, the joint state will be 
    \[
       \frac{1}{\sqrt{N}} \sum_{h \in G} \cas\!\Big(\frac{2\pi \langle g,h \rangle}{N}\Big)\, |h\rangle \otimes |h*x_0\rangle.
    \] 
    Because the Hartley transform combines what would be cosine and sine terms, this state is not as nicely factorable as in the Fourier case. In the Fourier case, we got $|g\rangle \otimes \text{(orbit state)}$. In the Hartley case, we do not get a single basis state in the first register; instead we get a superposition in the first register with real coefficients $c_h = \cas(2\pi\langle g,h\rangle/N)$. However, note that $c_h$ is just some real number in $[-1,1]$ depending on $g$ and $h$. Another way to express the above state is:
    \[
      |\$\rangle = \frac{1}{\sqrt{N}} \sum_{x \in X} \Big(\frac{1}{\sqrt{N}}\sum_{h: h*x_0 = x} \cas\!\big(\frac{2\pi \langle g,h \rangle}{N}\big)\Big)\, |x\rangle.
    \] 
    Since for a given $x\in X$, all $h$ such that $h*x_0=x$ have the form $h = u g$ for a unique $u \in G$ (because the action is free and transitive), one can simplify the internal sum using properties of the cas function. But we need not dive into that here.
    \item No measurement of the first register is performed. In fact, we do not have a nice product state separation, so we cannot simply measure one register to get $g$. Instead, the output of minting is just the quantum state $|\$\rangle$ (which is entangled between what used to be two registers) and the known classical serial number $g$ (we know what $g$ we picked).
\end{enumerate}

The resulting money state $|\$\rangle$ has only real amplitudes (because the initial superposition was real and the controlled operation doesn’t introduce complex numbers, and the Hartley transform yields real coefficients). In particular, in the computational basis of $X$, the state $|\$\rangle$ is some real-vector state (with both positive and negative values possible). We can think of it as a “Hartley orbit state” corresponding to $g$.

The verification algorithm in our Hartley-based scheme attempts to mirror the Fourier-based verification: it will use the given serial $g$ and try to check the state. A first idea would be: do exactly the same as Zhandry’s verify (the group-action kickback and measure). However, this fails in certain cases. Specifically, the Hartley transform being real causes an ambiguity: it turns out that there exist distinct $g \neq g'$ for which the Hartley-based states $|\$\rangle_g$ and $|\$\rangle_{g'}$ are not orthogonal, and the original verification might accept a forged state that is a certain superposition. In fact, the verification algorithm might accept an illegitimate state with some probability bounded away from zero. This is the “breakdown” of the straightforward Hartley substitution that we alluded to earlier.

To address this, our verification algorithm takes a more sophisticated approach:
\begin{enumerate}
    \item Given $(g, |\psi\rangle)$, it first uses the \textbf{quantum walk-based phase estimation} method (to be detailed in Chapter 6) to \emph{compute the eigenphase corresponding to $g$}. In short, we will treat $|\psi\rangle$ as an eigenvector of the group action adjacency matrix with a certain eigenvalue $\lambda$ related to $g$. We run a procedure to estimate $\lambda$ to high precision.
    \item From the estimated eigenvalue(s), we reconstruct a candidate group element $g^*$ that we believe generated the state. (This uses the fact that by running phase estimation for multiple carefully chosen walk durations, one can solve for $g$ as shown in [31].)
    \item We check if $g^* = g$ (the serial number provided). If not, we reject, since the state does not match the serial. If yes, we accept.
\end{enumerate}

This procedure essentially extracts the hidden group element from the state and compares it to the claimed serial. If an adversary tries to forge a state $|\psi\rangle$ for a known serial $g$, the only way to consistently pass verification is if $|\psi\rangle$ truly encodes the same $g$ in its eigen-spectrum. A fake note that was causing trouble for the naive Hartley verification (e.g., a state that is a mixture of two different “Hartley orbit” states) would yield an eigenphase that does not correspond to a single valid $g$, and the algorithm would detect the mismatch.

The key quantum tool enabling this verification is the continuous-time quantum walk on the group action graph and the ability to simulate it, which we prepared in Chapter 4. The walk Hamiltonian $A(X,S)$ has the genuine money state $|\$\rangle_g$ as an eigenstate with a known eigenvalue $\lambda(g)$. By running phase estimation on $e^{-iA t}$ with the state $|\psi\rangle$, we attempt to measure that eigenvalue. We repeat for a few different values of $t$ (the “twists” or different phases) to get enough information to pinpoint $g$. This approach can be viewed as adding extra “twists” to the verification: effectively, each choice of $t$ in phase estimation is like looking at the state in a different interference fringe pattern, analogous to applying different group actions as twists in the verification procedure. This is why we described the new verification as using group action twists—by varying a continuous parameter related to the group action’s eigenvalues, we break the symmetry that allowed a counterfeit to slip through.

We defer the full analysis of the success probabilities and how many repetitions are needed to Chapter 6, where we describe the verification algorithm in detail. For now, the takeaway is that by using the quantum walk approach, we can reliably verify Hartley-based money states, restoring security while still enjoying the properties of real amplitudes.

\section{Efficient Quantum Hartley Transform Implementation}
Before moving on to the verification algorithm, we briefly discuss how we implement the quantum Hartley transform (QHT) efficiently, as this is an important practical aspect of our scheme. The Fourier transform is well-known to have efficient circuits; for the Hartley transform, fewer results are available, so we contributed a new circuit construction.

The QHT we need is over an abelian group, which for concreteness one can think of as $\mathbb{Z}_N$ (the general finite abelian group case can usually be reduced to a direct sum of cyclic groups, applying QHT on each cyclic component). Classical Hartley transforms have a recursive structure similar to fast Fourier transforms. In fact, there are known formulas to express a Hartley transform of size $N$ in terms of two Hartley transforms of size $N/2$ plus some additional linear operations [25]. We leveraged such structures to design a divide-and-conquer quantum circuit.

Our algorithm for QHT works roughly as follows:
- If $N$ is even, we can express the length-$N$ Hartley transform in terms of two length-$N/2$ Hartley transforms plus a combination of cheap operations (additions, permutations of data, etc.). We implement this decomposition recursively as a quantum circuit. The base of the recursion is when the size is small (like $N=2$ or $4$, where the transform can be done with a constant number of gates).
- We found that by carefully optimizing this recursion and using some known quantum subroutines for certain linear combinations, the overall gate count is improved compared to naive methods or previous proposals [21, 22]. In particular, our circuit avoids introducing any quantum Fourier transform internally (unlike [22] which computed Hartley via Fourier plus some adjustments), and this yields a purely real rotation-based circuit.
- The resulting complexity for an $N$-point QHT is $O(N \log N)$ basic quantum gates (up to polylog factors for precision), which is on par (up to constant factors) with the complexity of a QFT circuit. We also derived explicit constants for small cases to show improvements over prior work.

Additionally, once we have an efficient QHT, we can also implement other related transforms. We demonstrate this with the example of the \textbf{quantum sine transform} (QST). The sine transform is another real transform closely related to Hartley (in fact, a sine transform can be implemented by a Hartley transform plus some pre- and post-processing). We gave a construction that uses one QHT as a subroutine to realize the QST on $N$ points. This had a similar complexity of $O(N \log N)$ gates. The broader implication is that a family of real-valued transforms (Hartley, sine, cosine, etc.) can all be efficiently performed on quantum hardware, which may have independent applications in signal processing or other quantum algorithms.

For the purposes of this thesis, the main point is: \emph{we can implement the Hartley transform needed for our money scheme with polynomial efficiency}. Thus, switching to the Hartley transform does not introduce any prohibitive cost. All steps of minting and verification remain efficient. Having covered the construction of the money scheme and the necessary tools, we now proceed to the final piece: the detailed verification algorithm using quantum walks, and an analysis of how it validates genuine banknotes and foils counterfeit attempts.
\vspace{1em}



\chapter{Verification Algorithm Using Quantum Walks}
The Hartley-based quantum money scheme introduced in the previous chapter requires a new verification procedure to address the issues that arise from using real amplitude states. In this chapter, we describe and analyze the verification algorithm, which leverages continuous-time quantum walks on the group action graph (and their efficient simulation from Chapter 4) to extract the information needed to authenticate a banknote.

    \section{Challenges with Naïve Verification}
    Before detailing the new algorithm, let us briefly recap why the straightforward approach fails. In the Fourier-based scheme, verification was done by a single “kickback” operation using the claimed serial $g$, and measuring an auxiliary register. In the Hartley-based scheme, if we attempted the analogous one-step verification, we would perform the controlled-$g$ action and measure the auxiliary system. A genuine state $|\$_g\rangle$ (the Hartley money state for serial $g$) would cause some interference pattern in the auxiliary register, but unlike the Fourier case, it does not return the auxiliary to $|x_0\rangle$ deterministically. In fact, there is an ambiguity: certain superpositions of eigenstates corresponding to $g$ and $-g$ (or other group-related variants) can produce the same measurement statistics in that one-step test. This means an adversary might prepare a counterfeit state that is not a legitimate $|\$_g\rangle$ but still passes the one-step verification with non-zero probability. Essentially, the Hartley transform being real means we lost some phase information, and a single measurement cannot distinguish some mirrored states.

    To overcome this, our strategy is to perform a more complete measurement of the state’s “phase spectrum.” Instead of just one operation and measurement, we will use the quantum walk (with Hamiltonian $A = A(X,S)$ as defined earlier) to perform a form of phase estimation.

    \section{Using Quantum Walks to Extract the Serial}
    The central observation is that the money state $|\$_g\rangle$ is an eigenstate of the walk’s Hamiltonian $A$ on the group action Cayley graph. To see this, note that $|\$_g\rangle$ (Fourier or Hartley) lies in the subspace spanned by $\{|x\rangle: x \in X\}$ (we no longer explicitly keep the group element register, since after minting it’s entangled or measured away). Consider the adjacency operator $A$ acting on a basis state $|x\rangle$. By definition,
    \[ A |x\rangle = \sum_{s \in S} |s * x\rangle, \] 
    summing over all neighbors under the generators. Now, $|\$_g\rangle$ is (up to normalization) $\sum_{h \in G} f(h)\, |h * x_0\rangle$ for some coefficient function $f(h)$. If one applies $A$ to this state:
    \[ A |\$_g\rangle = \sum_{s \in S} \sum_{h \in G} f(h)\, |s * (h * x_0)\rangle = \sum_{h \in G} f(h)\, \sum_{s \in S} |(sh) * x_0\rangle. \]
    Now change variable $h' = sh$ in the inner sum. Since $s$ runs over all of $S$, $h'$ runs over $S h = \{sh: s \in S\}$ which is exactly the set of neighbors of $h$ in the Cayley graph of $G$. For an abelian group, one can show (and it is known from spectral graph theory) that $\sum_{s \in S} |sh * x_0\rangle$ corresponds to the same state as $\lambda_g |h * x_0\rangle$ where $\lambda_g = \sum_{s\in S} \chi_g(s)$ for Fourier states, or $\lambda'_g = \sum_{s\in S} \cas(2\pi \langle g,s\rangle/N)$ for Hartley states. In short, $|\$_g\rangle$ is an eigenvector of $A$ with eigenvalue $\lambda_g'$ (a real number that depends on $g$ and $S$). This fact was formalized earlier: Lemma 8.2 showed that the money state is an eigenstate of $A$.

    For example, if $G = \mathbb{Z}_N$ and $S=\{1, -1\}$, a Fourier-based $|\$_g\rangle$ is essentially the character $\chi_g$, and indeed $\chi_g$ is an eigenfunction of the adjacency (which is like a cosine operator) with eigenvalue $2\cos(2\pi g/N)$. The Hartley-based state corresponds to a combination of $\chi_g$ and $\chi_{-g}$ (the real and imaginary parts combined), and ends up with the same eigenvalue $2\cos(2\pi g/N)$ as well. So either way, the “frequency” $g$ maps to a specific eigenvalue $\lambda$.

    The verification algorithm will do the following: it will run phase estimation on the unitary $U = e^{iA\tau}$ for some carefully chosen time $\tau$, using the state $|\psi\rangle$ as input. Phase estimation is a standard quantum algorithm that, given an eigenstate of $U$, yields an estimate of the eigenphase $2\pi \phi$ (where $e^{i 2\pi \phi}$ is the eigenvalue of $U$) to some specified precision. In our case, since $A$ has eigenvalue $\lambda$ on $|\psi\rangle = |\$_g\rangle$, the unitary $e^{iA\tau}$ has eigenvalue $e^{i \lambda \tau}$. Thus phase estimation will give us an estimate of $\lambda \tau \pmod{2\pi}$. By choosing $\tau$ appropriately, we can ensure $\lambda \tau$ uniquely corresponds to $\lambda$ (within the precision we work at).

    We cannot run $e^{iA\tau}$ directly, but Chapter 4 showed how to simulate it efficiently with a discrete-time algorithm. So when we say “phase estimation on $U = e^{iA\tau}$,” we imply using the simulation routine as a subroutine in the phase estimation circuit. This will incur some error $\epsilon$, but we can make it negligible with enough resources.

    Now, because $\lambda$ (the eigenvalue of $A$) is related to $g$, obtaining $\lambda$ in effect gives us information about $g$. However, one eigenvalue might correspond to two possible $g$ values (e.g., $\cos(2\pi g/N) = \cos(2\pi (N-g)/N)$). So a single run of phase estimation may not fully determine $g$. This is where performing the procedure for multiple different times $\tau$ (or perhaps using a slightly different Hamiltonian) helps. By getting $\lambda$ at different scales, we can solve for $g$ using the known functional form of $\lambda$ in terms of $g$. 

    In [31], it was shown that by using two or three carefully chosen multiples of time (or equivalently using the fact that $\lambda$ as a function of $g$ has a known form like a cosine series), one can uniquely recover $g$. In our scheme, since $S$ is known and fixed, and presumably $S$ is such that the map $g \mapsto \lambda_g = \sum_{s\in S} \chi_g(s)$ is injective up to trivial symmetries, a few phase estimates suffice. For instance, if $S=\{1,-1\}$, knowing $\cos(2\pi g/N)$ to high precision lets you determine $g$ up to the symmetry $g \leftrightarrow N-g$. But if we also had a way to break the symmetry (maybe by using an asymmetric choice of $\tau$ or an additional generator in $S$ that is not symmetric), we can get the sign too. Alternatively, we run phase estimation on a slightly modified Hamiltonian $A'$ (maybe corresponding to a different generating set that breaks symmetry) if available.

    For simplicity, let’s suppose two runs with different $\tau$ values are enough. The output of the verification algorithm is then determined by:
    - If the estimated $g^*$ from the phase(s) matches the provided serial $g$, output \texttt{accept}.
    - Otherwise, output \texttt{reject}.

    Because a genuine $|\$_g\rangle$ is exactly an eigenstate with eigenvalue $\lambda_g$, phase estimation will return (with high probability) a number very close to $\lambda_g \tau$ modulo $2\pi$. Given the precision, we decode it to the nearest valid $\lambda_{g'}$ value, which should be $\lambda_g$. Hence we recover $g'=g$ and accept. For a counterfeit state, two things can happen:
    1. The state $|\psi\rangle$ is a superposition of eigenstates (not a single eigenstate). In that case, phase estimation will give some distribution of eigenvalues, effectively picking one at random (with probabilities proportional to the projection of $|\psi\rangle$ onto those eigencomponents). It is highly unlikely that this random outcome consistently points to the same $g^*$ that the adversary wants (especially if they try to match a specific $g$ that they announced as serial). In fact, unless the counterfeit state was itself aligned with one particular eigenvalue, the measurement will likely produce a result that does not correspond to the claimed serial, leading to rejection.
    2. The state $|\psi\rangle$ happens to be an eigenstate, but with a wrong eigenvalue (i.e., corresponding to some $g' \neq g$). In that case, the phase estimation will reliably give $\lambda_{g'}$, and we will decode $g'$ which won’t match the claimed $g$, so we reject. This scenario would occur if the adversary somehow prepared a valid-looking state for a different serial $g'$ but presented it with serial $g$—clearly that should be rejected.

    Thus, the only way to pass is to present a state that is an eigenstate with eigenvalue matching the serial. But the only known way to produce such a state is essentially to follow the minting procedure (due to the one-wayness of the group action, they can’t derive $|\$_g\rangle$ without knowing $g$ or breaking the assumption).

    One might wonder: phase estimation is a probabilistic algorithm; what if it sometimes yields the correct $g^*$ and sometimes not, could an adversary repeat the verification or something? In practice, the banknote verification either passes or fails once; an adversary doesn’t get to try multiple times on the same note without potentially decohering it or being caught. We design our parameters such that the completeness (accepting a good note) is very high and the soundness (accepting a forgery) is extremely low, say negligible in $n$. This might involve repeating the phase estimation a constant number of times to amplify confidence, or using a high precision so that the error probability is negligible.

    Finally, our algorithm implicitly uses the ability to perform the controlled-$U$ operations for phase estimation. That is non-trivial but our quantum walk simulation provided a way to implement $e^{iA\tau}$, and controlled versions can be constructed by controlling each gate in the simulation (which increases complexity by at most a factor poly(n)). We have to ensure that the simulation error is accounted for in the phase estimation accuracy—this can be handled by choosing simulation parameters fine enough that the error is smaller than the inverse of our runtime or something along those lines.

    \section{Detailed Verification Procedure}
    To summarize, here is a more step-by-step description of the verification algorithm for a banknote $(g, |\psi\rangle)$:
    \begin{enumerate}
        \item **Preparation:** Determine a set of one or more time parameters $\{\tau_1, \tau_2, \dots, \tau_m\}$ to be used for phase estimation. These might be hardcoded or depend on $N$ and $S$. For example, $\tau_1$ could be a basic time and $\tau_2$ another that breaks degeneracy.
        \item **Phase Estimation Rounds:** For each $\tau_j$:
        \begin{enumerate}
            \item Use the quantum walk simulation circuit to implement controlled-$e^{iA \tau_j}$ on $|\psi\rangle$. (In practice, we append an ancilla register to accumulate the phase, as in standard phase estimation algorithms. We prepare a uniform superposition over some range of time steps, apply controlled-$U$ gates, and perform inverse Fourier transform on the phase register to get an estimate. This is the standard routine.)
            \item Measure the phase register to obtain an estimate $\tilde{\phi}_j$ of $\lambda_g \tau_j / (2\pi)$ (mod 1). Multiply by $2\pi/\tau_j$ to get an estimate $\tilde{\lambda}_j$ of $\lambda_g$.
        \end{enumerate}
        \item **Compute Serial Candidate:** From the collection $\{\tilde{\lambda}_j\}$, solve for the group element $g^*$ that would produce those eigenvalues. This might involve inverting the known relation $\lambda = \sum_{s\in S}\cas(2\pi \langle g, s\rangle/N)$ or whatever the formula is in our context. Because of estimation error, we choose the nearest matching $g^*$ in $G$ that would give eigenvalues close to the $\tilde{\lambda}_j$ observed.
        \item **Accept/Reject:** If $g^* = g$ (and all rounds of phase estimation yielded results consistent with a single $g^*$, which should happen for a valid note), then output \texttt{accept}. Otherwise, output \texttt{reject}.
    \end{enumerate}

    This algorithm may seem complex, but it can be optimized. In practice, we could combine multiple phase estimation steps into one larger quantum circuit that extracts $g$ in one go, but conceptually, it’s easier to think of them separately.

    \section{Analysis of Security and Efficiency}
    The new verification algorithm is more involved than the original Fourier-based one, so we must check that it is still efficient and that it indeed thwarts counterfeiting.

    **Efficiency:** Each phase estimation round uses polynomial-time quantum operations. The Hamiltonian simulation of $e^{iA\tau}$ for sparse $A$ on $N$-dimensional space can be done in $\operatorname{poly}(\log N)$ time (since queries to the group action oracle are $O(1)$ and $|S|$ is small). The phase estimation itself might need $O(\log N)$ qubits of precision to distinguish different $g$ values, and $O(\log N)$ repetitions of $U$ in superposition. Overall, each round is $\operatorname{poly}(n)$ time. A constant number of rounds doesn’t change the polynomial class. So yes, verification is QPT. In fact, in asymptotic terms, if minting took $\tilde{O}(n^c)$ time, verification might take $\tilde{O}(n^{c+1})$ or similar due to extra overhead, but still polynomial.

    **Completeness:** A genuine banknote state $|\$_g\rangle$ will be accepted with high probability. The state is an eigenstate of $A$, so phase estimation yields exactly $\lambda_g$ (with small error $\epsilon$). Decoding that yields $g^* = g$. The only possible errors are from phase estimation not being perfect: there is a small probability it gives the wrong eigenvalue estimate (exponentially small in the number of ancilla qubits used). By choosing parameters, we ensure this error is negligible, say $< 2^{-n}$ or similar. So the chance a real note is mistakenly rejected is negligible.

    **Soundness:** A counterfeiter’s goal is to have $\mathsf{Verify}(g, |\psi\rangle) = \texttt{accept}$ for some $|\psi\rangle$ that they created without running $\mathsf{Mint}$. Essentially, they either try to reuse a state they already saw or combine states to get two accepted notes, etc. If they attempt to create a new state for an unused serial $g$, they face the following:
    - If $|\psi\rangle$ is not an eigenstate of $A$, when we run phase estimation, the outcome is a random eigenvalue from its spectral decomposition. It would be a huge coincidence if that random eigenvalue corresponded to exactly the claimed $g$. And even if by some luck one phase estimation round gave a favorable result, with two rounds the chance to consistently impersonate the same $g$ is even smaller. In fact, by the union bound, the probability that a wrong state passes all checks should be negligible. A rigorous argument would be that if $|\psi\rangle$ has overlap on eigenstates $\{|e_j\rangle\}$ with eigenvalues $\lambda_j$, then the verification accepts only if for all $j$ with nonzero overlap, the decoded $g_j$ equals the claimed $g$. If any overlap component has a different underlying group element, that component will cause failure in at least one of the phase estimation rounds with high probability. Unless the state was aligned to one particular $g'$, in which case the best they can do is claim it is $g'$.
    - If $|\psi\rangle$ \emph{is} an eigenstate but for $g' \neq g$, then our algorithm will find $g'$ and compare to $g$ and reject. So the adversary would have to guess the serial number’s eigenstate perfectly, which means they basically guessed the bank’s secret or solved the one-way problem.

    The most cunning forgery could be to use a genuine note $(g, |\$_g\rangle)$ and try to produce a second independent state $|\$_g\rangle$ for the same $g$. But that is essentially copying a quantum state which is unknown to them (they only know $g$ classically). Given $g$, can they produce $|\$_g\rangle$? That’s the one-way group action problem: producing $|\$_g\rangle$ is as hard as computing $g*x_0$ for all group elements in superposition, which requires knowledge of $g$ in a way that they don't have (they know $g$ but to create the superposition exactly with correct phases is akin to solving for the hidden phase structure—likely hard without the trapdoor). In fact, if they could do that efficiently for any given $g$, they would break the scheme by minting their own money. So by assumption, that’s infeasible.

    Thus, the only resource the adversary has is perhaps other genuine notes they possess. Could they entangle two notes or something to produce two valid ones? If they have one note, trying to make two will likely destroy the original or produce two imperfect copies that fail verification (no-cloning strikes again). If they have two different notes $(g_1, |\$_{g_1}\rangle)$ and $(g_2, |\$_{g_2}\rangle)$, those states are independent, and forging a new one still reduces to above.

    Therefore, we argue the scheme remains secure: forging in any meaningful sense would require solving a hard problem (inverting the group action or cloning a quantum state).

    In conclusion, by using continuous-time quantum walks and phase estimation, our verification algorithm retrieves the hidden serial number encoded in the quantum money state and compares it to the claimed serial. This not only fixes the issue introduced by using the Hartley transform (real amplitudes), but it does so in polynomial time. We have thus achieved a public-key quantum money scheme based on standard assumptions (one-way group actions) with an extra novel feature of using real-valued quantum states and demonstrating the power of quantum walks in quantum cryptanalysis and verification.















% \section*{Introduction}

% Quantum computing is a revolutionary field that combines quantum mechanics and information theory to redefine computation and information processing. In the latter part of the 20th century, scientists explored the fusion of quantum mechanics and information theory, leading to the birth of quantum information science. This field challenges the classical view of computation by introducing novel concepts like quantum bits (qubits), entanglement, and quantum superposition, which have enabled new algorithms and protocols that outpace their classical counterparts in specific tasks. Classical computers are grounded in bits, which take binary values (0 or 1). Quantum computing introduces the qubit, a fundamental unit of quantum information that can exist in a superposition of states, such as 0 and 1 simultaneously. This foundational difference enables quantum computers to process information in fundamentally new ways. Unlike technologies like DNA computing or optical computing, which describe changes in the physical substrate while retaining classical computational principles, quantum computing changes the computational paradigm itself. A quantum computer uses the principles of quantum mechanics, such as superposition and entanglement, rather than classical mechanics, to process information. In the 1980s, pioneers like Richard Feynman and David Deutsch recognized that certain quantum phenomena could not be efficiently simulated on classical computers. These insights led to the exploration of quantum Turing machines and quantum circuit models, which provided a theoretical framework for quantum computing. The discovery of quantum gates and their role in quantum algorithms formalized the field.

% Early quantum algorithms demonstrated that quantum computing could solve certain problems more efficiently than classical methods. Notably, in 1994, Peter Shor introduced a polynomial-time quantum algorithm for integer factorization, which threatened classical cryptographic protocols relying on the difficulty of factoring large integers. Entanglement, a uniquely quantum phenomenon, allows particles to exhibit correlations that defy classical explanation. This property is crucial for many quantum algorithms and protocols, as it enables quantum computers to process and store information in a way that classical computers cannot. Two notable algorithms underscore the potential of quantum computing: Shor’s Algorithm, which efficiently factors integers, undermining RSA encryption and other cryptographic systems based on the hardness of factoring, and Grover’s Algorithm, which provides a quadratic speedup for unstructured search problems, such as searching an unsorted database. These algorithms exemplify the theoretical advantages of quantum computing over classical approaches, even though practical implementations remain challenging.

% Quantum systems are fragile and susceptible to decoherence, where quantum states lose their coherence due to interactions with the environment. This makes maintaining quantum states for computation a significant challenge. Quantum error correction methods were developed to address decoherence and other quantum noise. The breakthrough work of Shor and Steane in the mid-1990s introduced error-correction codes that allowed reliable computation despite quantum noise. Building scalable quantum computers requires advances in hardware and experimental techniques. As of now, only small-scale quantum systems with a few qubits have been implemented successfully in laboratories. Quantum computing does not offer universal speedups for all problems. For example, Grover’s algorithm provides only a quadratic speedup for unstructured search, and certain problems remain equally challenging for both quantum and classical computers.

% Quantum key distribution protocols, like BB84 and Ekert’s protocol, offer provably secure methods for communication based on the principles of quantum mechanics. Unlike classical cryptography, which relies on computational assumptions, quantum cryptography guarantees security through physical principles. The quantum perspective has provided new insights into classical computing and inspired novel classical algorithms. It has also advanced simulation techniques for quantum systems, benefiting fields like material science and chemistry. Quantum information processing has deepened our understanding of quantum mechanics, shedding light on foundational questions about quantum measurement and entanglement. For example, experiments testing Bell’s inequalities have confirmed the non-classical correlations predicted by quantum theory.

% While practical quantum computing is still in its infancy, significant progress has been made. Quantum hardware companies like IBM, Google, and Rigetti have developed small-scale quantum processors capable of performing limited computations. Platforms such as Qiskit and Cirq enable researchers to experiment with quantum programming and algorithm development. Efforts to build scalable, fault-tolerant quantum computers are ongoing, alongside investigations into alternative models of quantum computation, such as topological and cluster-state quantum computing. Despite these advances, many open questions remain about the scope and ultimate power of quantum computation. While quantum computers will not replace classical ones for all tasks, they promise to revolutionize fields where their unique capabilities provide exponential speedups or new forms of computation.

% Quantum computing represents a profound shift in how we understand and leverage computation. By replacing classical mechanics with quantum mechanics as the foundation for processing information, quantum computing has opened new avenues for scientific discovery and technological innovation. While challenges persist, the theoretical and experimental advances made thus far underscore the transformative potential of this exciting field.


% \section*{Foundations of Quantum Computation}



% \section*{Understanding a Qubit}
% A qubit (quantum bit) is the fundamental unit of quantum information, analogous to a classical bit. However, unlike a classical bit, which can only exist in one of two definite states ($0$ or $1$), a qubit can exist in a linear combination, or superposition, of both states simultaneously. Mathematically, the state of a single qubit is represented as:

% \begin{equation}
% |\psi\rangle = \alpha |0\rangle + \beta |1\rangle
% \end{equation}

% Here:
% \begin{itemize}
%     \item $|0\rangle$ and $|1\rangle$ are the basis states (analogous to $0$ and $1$ in classical computing).
%     \item $\alpha$ and $\beta$ are complex numbers known as probability amplitudes.
% \end{itemize}

% The normalization condition \(|\alpha|^2 + |\beta|^2 = 1\) ensures that the probabilities of measuring the qubit in either the $|0\rangle$ or $|1\rangle$ state sum to 1.

% The qubit's unique ability to exist in a superposition of states is what gives quantum computers their immense computational potential, enabling them to process and store information in fundamentally different ways than classical computers.

% \section*{Superposition}
% Superposition is a quantum phenomenon where a qubit exists in a combination of multiple states simultaneously. For example, a qubit in the state:

% \begin{equation}
% |\psi\rangle = \frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle
% \end{equation}

% is in an equal superposition of $|0\rangle$ and $|1\rangle$. This means that if we measure the qubit, there is an equal probability (50\%) of observing it in either state.

% Key properties of superposition:
% \begin{itemize}
%     \item \textbf{Parallelism:} When a quantum system is in superposition, it can perform computations for all possible states simultaneously. For instance, a single qubit can encode two states ($|0\rangle$ and $|1\rangle$) at the same time, while $n$ qubits can encode $2^n$ states.
%     \item \textbf{Measurement Collapse:} When a qubit in superposition is measured, it collapses into one of its basis states, $|0\rangle$ or $|1\rangle$, with a probability given by $|\alpha|^2$ and $|\beta|^2$, respectively.
% \end{itemize}

% Superposition allows quantum systems to explore multiple possibilities in parallel, which is critical for quantum algorithms such as Grover's search or Shor's factoring.

% \section*{Entanglement}
% Entanglement is a uniquely quantum phenomenon where two or more qubits become correlated in such a way that the state of one qubit is directly related to the state of the other, regardless of the physical distance between them. When qubits are entangled, the measurement of one qubit instantly determines the state of the other.

% An example of an entangled state for two qubits is the Bell state:

% \begin{equation}
% |\psi\rangle = \frac{1}{\sqrt{2}} (|00\rangle + |11\rangle)
% \end{equation}

% Here:
% \begin{itemize}
%     \item $|00\rangle$ means both qubits are in the $|0\rangle$ state.
%     \item $|11\rangle$ means both qubits are in the $|1\rangle$ state.
% \end{itemize}

% If one qubit is measured to be $|0\rangle$, the other qubit will instantly collapse to $|0\rangle$, and similarly for $|1\rangle$, regardless of the distance between them.

% Key features of entanglement:
% \begin{itemize}
%     \item \textbf{Non-Local Correlations:} Entanglement defies classical intuition, as it suggests that measurement outcomes are correlated even across vast distances, a phenomenon supported by experiments validating Bell's Theorem.
%     \item \textbf{Applications:} Entanglement is a resource for many quantum technologies, including quantum teleportation, quantum cryptography (e.g., secure communication via the BB84 protocol), and quantum error correction.
% \end{itemize}

% Entanglement, along with superposition, forms the backbone of quantum computing and quantum communication, enabling capabilities that are impossible in the classical world.




% \subsection*{Quantum Gates and Circuits}


% Quantum logic gates are the fundamental building blocks of quantum circuits, manipulating qubits—the basic units of quantum information. Unlike classical logic gates, quantum gates are reversible and represented by unitary matrices, ensuring the preservation of quantum information.

% \subsection*{Key Quantum Logic Gates}

% \subsubsection*{1. Pauli-X Gate (NOT Gate)}
% \textbf{Operation:} Flips the state of a qubit from $|0\rangle$ to $|1\rangle$ and vice versa. \\
% \textbf{Matrix Representation:}
% \[
% X = 
% \begin{bmatrix}
% 0 & 1 \\
% 1 & 0
% \end{bmatrix}
% \]

% \subsubsection*{2. Hadamard Gate (H Gate)}
% \textbf{Operation:} Creates a superposition state, transforming $|0\rangle$ into $\frac{|0\rangle + |1\rangle}{\sqrt{2}}$ and $|1\rangle$ into $\frac{|0\rangle - |1\rangle}{\sqrt{2}}$. \\
% \textbf{Matrix Representation:}
% \[
% H = \frac{1}{\sqrt{2}}
% \begin{bmatrix}
% 1 & 1 \\
% 1 & -1
% \end{bmatrix}
% \]

% \subsubsection*{3. Controlled-NOT Gate (CNOT Gate)}
% \textbf{Operation:} A two-qubit gate that flips the state of the target qubit if the control qubit is in the state $|1\rangle$. \\
% \textbf{Matrix Representation:}
% \[
% CNOT =
% \begin{bmatrix}
% 1 & 0 & 0 & 0 \\
% 0 & 1 & 0 & 0 \\
% 0 & 0 & 0 & 1 \\
% 0 & 0 & 1 & 0
% \end{bmatrix}
% \]


% \subsection*{Universal Gates}
% A set of gates is considered \textbf{universal} if any unitary operation can be approximated to arbitrary precision using a sequence of gates from this set. For example, single-qubit rotation gates combined with the CNOT gate form a universal set, enabling the construction of any quantum algorithm.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Introduction to Quantum Walks}


% The concept of a \textit{quantum walk} is a quantum analog of the classical random walk and plays a significant role in quantum algorithms. There are two main types of quantum walks: \textit{continuous-time} and \textit{discrete-time} quantum walks, both of which exhibit behaviors that are significantly different from classical random walks.


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section*{Continuous-Time Quantum Walks}


% Classical continuous-time random walks (Markov chains) are a foundational concept in stochastic processes, where time is treated as a continuous variable. In this framework, a walker moves from one vertex of a graph to an adjacent vertex at any time, with probabilities evolving over time. The probability of the walker being at a vertex can be visualized as a liquid seeping from one vertex to its neighbors. Initially, the walker is most likely to be found at the starting vertex, but as time progresses, the probability shifts to neighboring vertices. This dynamic is governed by a constant transition rate \( \gamma \), uniform across all vertices and time.

% To model this mathematically, the probability of transitioning from one vertex to another in an infinitesimal time interval \( \Delta t \) is proportional to \( \gamma \Delta t \). For a vertex \( x_j \) with degree \( d_j \) (the number of neighboring vertices), the probability of the walker staying on \( x_j \) is 

% \[
% 1 - d_j \gamma \Delta t,
% \]

% while the probability of transitioning to a neighboring vertex is 

% \[
% \gamma \Delta t.
% \]

% The evolution of probabilities over time is captured by the transition matrix \( M(t) \), where the entry \( M_{ij}(t) \) represents the probability of transitioning from vertex \( x_j \) to vertex \( x_i \) in time \( t \). The dynamics of the system are described by a differential equation derived from the transition matrix and an auxiliary matrix \( H \), known as the generating matrix. This equation, 

% \[
% \frac{dM(t)}{dt} = -H M(t),
% \]

% has a solution expressed as 

% \[
% M(t) = e^{-Ht},
% \]

% which allows for the computation of probability distributions at any given time. The solution is verified using the Taylor series expansion of the exponential function.

% The passage from classical continuous-time Markov chains to quantum walks involves a standard quantization process. In classical random walks, probabilities evolve via the transition matrix \( M \). In contrast, the quantization process replaces the vector of probabilities with a state vector (probability amplitudes) and the non-unitary transition matrix with a unitary evolution operator, as required by quantum mechanics. This involves transforming the generating matrix \( H \) into a Hermitian operator and then constructing a unitary operator 

% \[
% U(t) = e^{-iHt}
% \]

% by multiplying \( H \) with the imaginary unit \( i \).

% In a continuous-time quantum walk, the quantum state evolves over time according to the unitary operator \( U(t) \). If the initial state of the system is \( |\psi(0)\rangle \), the state at time \( t \) is given by 

% \[
% |\psi(t)\rangle = U(t) |\psi(0)\rangle.
% \]

% The probability distribution for observing the walker at a specific vertex \( k \) is computed as 

% \[
% p_k = |\langle k | \psi(t) \rangle|^2,
% \]

% where \( |k\rangle \) represents the state corresponding to vertex \( k \).

% The continuous-time quantum walk introduces several key differences from its classical counterpart. Unlike classical random walks, which rely on probabilities, quantum walks involve probability amplitudes, enabling interference effects. These effects allow quantum walks to explore the graph more efficiently, leading to applications in quantum algorithms with speedups over classical approaches. Additionally, the transition matrix in classical random walks is replaced with a Hermitian operator in the quantum case, ensuring unitary evolution.



% \subsection*{Example: Continuous-Time Quantum Walk on the Line}

% To illustrate the behavior of continuous-time quantum walks, consider the example of a particle evolving on the \textit{infinite one-dimensional lattice}, also known as the \textit{integer line}. In this graph, the vertices are labeled by integers \( \mathbb{Z} \), and each vertex \( n \in \mathbb{Z} \) is connected to its immediate neighbors \( n-1 \) and \( n+1 \). The adjacency matrix \( A \) for this graph has entries:
% \[
% A_{i,j} =
% \begin{cases}
% 1 & \text{if } |i - j| = 1, \\
% 0 & \text{otherwise}.
% \end{cases}
% \]

% Let the walker initially be located at the origin, so the initial state is \( |\psi(0)\rangle = |0\rangle \). The quantum evolution of the system is governed by the Schrödinger equation:
% \[
% i \frac{d}{dt} |\psi(t)\rangle = A |\psi(t)\rangle,
% \]
% with the solution:
% \[
% |\psi(t)\rangle = e^{-iAt} |\psi(0)\rangle.
% \]

% For this specific graph, the amplitude of being at position \( n \) at time \( t \) has an elegant closed-form expression:
% \[
% \psi_n(t) = i^n J_n(2t),
% \]
% where \( J_n \) is the \textit{Bessel function of the first kind} of order \( n \). The corresponding probability of finding the walker at vertex \( n \) at time \( t \) is:
% \[
% p_n(t) = |\psi_n(t)|^2 = |J_n(2t)|^2.
% \]

% This probability distribution displays quintessential quantum behavior: it is \textbf{non-Gaussian}, \textbf{oscillatory}, and \textbf{spreads faster} than in the classical case. In contrast to the diffusive behavior of classical walks, where the standard deviation grows as \( \sigma(t) \propto \sqrt{t} \), the quantum walk exhibits \textit{ballistic spread} with \( \sigma(t) \propto t \).

% These interference-driven properties make CTQWs particularly powerful for applications in quantum information and quantum algorithms, where the speed and spread of information are crucial.




% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section*{Discrete-Time Quantum Walks}



% Discrete-time quantum walks (DTQWs) serve as the discrete counterpart of quantum random walks and are particularly useful for algorithmic constructions in quantum computing. Unlike continuous-time quantum walks, DTQWs require an additional coin degree of freedom to preserve unitarity in the evolution. In this section, we explore the discrete-time coined quantum walk on the infinite one-dimensional lattice (integer line), which provides a clear and tractable example of how interference and superposition govern quantum behavior.

% \subsubsection*{Hilbert Space and Coin Space}

% The state space of the system is the tensor product \( \mathcal{H} = \mathcal{H}_C \otimes \mathcal{H}_P \), where:
% \begin{itemize}
%     \item \( \mathcal{H}_C \) is the 2-dimensional Hilbert space of the quantum coin, with basis states \( \{|0\rangle, |1\rangle\} \), often interpreted as ``spin up'' and ``spin down''.
%     \item \( \mathcal{H}_P \) is the position Hilbert space, spanned by \( \{|n\rangle : n \in \mathbb{Z}\} \), representing the particle's location on the integer line.
% \end{itemize}

% \subsubsection*{Coin and Shift Operators}

% The walk consists of two operations applied in sequence:
% \begin{enumerate}
%     \item \textbf{Coin operator \( C \)}: A unitary operator acting on \( \mathcal{H}_C \), typically chosen to create superposition. A common choice is the \textit{Hadamard coin}:
%     \[
%     H = \frac{1}{\sqrt{2}} \begin{bmatrix}
%     1 & 1 \\
%     1 & -1
%     \end{bmatrix}.
%     \]
%     \item \textbf{Shift operator \( S \)}: A unitary operator on \( \mathcal{H}_C \otimes \mathcal{H}_P \) that moves the walker depending on the coin state:
%     \[
%     S|0\rangle|n\rangle = |0\rangle|n + 1\rangle, \quad
%     S|1\rangle|n\rangle = |1\rangle|n - 1\rangle.
%     \]
% \end{enumerate}

% One full step of the walk is implemented by applying the unitary operator:
% \[
% U = S (C \otimes I_P),
% \]
% where \( I_P \) is the identity operator on \( \mathcal{H}_P \). Repeated application of \( U \) evolves the quantum state over time:
% \[
% |\psi(t)\rangle = U^t |\psi(0)\rangle.
% \]

% \subsubsection*{Example: Hadamard Walk from the Origin}

% Suppose the initial state of the system is localized at the origin with coin state \( |0\rangle \):
% \[
% |\psi(0)\rangle = |0\rangle \otimes |0\rangle.
% \]
% Applying the Hadamard operator and then the shift, the system evolves after one step into a superposition:
% \[
% |\psi(1)\rangle = \frac{1}{\sqrt{2}} \left( |0\rangle|1\rangle + |1\rangle|-1\rangle \right).
% \]
% The particle is now in a coherent superposition of being at positions \( +1 \) and \( -1 \), determined by its coin state.

% This process continues iteratively. For example, the second and third steps yield:
% \begin{align*}
% |\psi(2)\rangle &= \frac{1}{2} \left( -|1\rangle|-2\rangle + (|0\rangle + |1\rangle)|0\rangle + |0\rangle|2\rangle \right), \\
% |\psi(3)\rangle &= \frac{1}{2\sqrt{2}} \left( |1\rangle|-3\rangle - |0\rangle|-1\rangle + (2|0\rangle + |1\rangle)|1\rangle + |0\rangle|3\rangle \right).
% \end{align*}

% \subsubsection*{Quantum vs Classical Behavior}

% The key difference between quantum and classical random walks lies in the presence of \textit{interference} and \textit{superposition}:
% \begin{itemize}
%     \item In classical random walks, probabilities are updated step-by-step based on stochastic transitions, leading to a binomial distribution that approximates a Gaussian as time progresses.
%     \item In contrast, discrete-time quantum walks generate probability amplitudes that can interfere constructively or destructively depending on the history of the evolution.
% \end{itemize}

% As a result, the probability distribution of the DTQW is not symmetric or Gaussian, and it spreads much faster than its classical counterpart. Specifically, the standard deviation of a DTQW grows linearly with time \( \sigma(t) \sim t \), while in the classical case it grows as \( \sqrt{t} \).


% If a position measurement is performed after every step, the quantum walk collapses into a classical random walk due to decoherence. However, by deferring measurement and allowing the system to evolve unitarily over many steps, quantum correlations between paths persist, yielding a rich interference pattern in the final probability distribution.


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection*{Comparison of Models}

% From a computational standpoint, both continuous-time and discrete-time quantum walks offer distinct advantages. The continuous-time quantum walk is often considered more natural because it does not require expanding the state space, making it simpler to define and typically easier to analyze. For example, while the exponential speedup demonstrated by continuous-time quantum walks is widely believed to extend to the discrete-time model, the dynamics of the latter are more complex. To date, no rigorous analysis has been provided to confirm this extension.

% In contrast, the discrete-time quantum walk is generally more straightforward to implement using quantum circuits. Implementing continuous-time quantum walks, however, often relies on techniques that require the graph's maximum degree to be small. This constraint makes certain algorithms challenging to replicate using continuous-time quantum walks. Therefore, while continuous-time quantum walks excel in simplicity and analytical tractability, discrete-time quantum walks offer greater practicality and ease of implementation in quantum computing applications.






% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Group Actions}


% Group actions provide a framework for understanding how groups interact with sets, formalizing the concept of applying transformations systematically. They capture the symmetries and structure-preserving transformations of objects, making them fundamental in mathematics and its applications. Group actions describe transformations through a set of rules that ensure consistency and compatibility with the underlying group operations. This concept is pivotal in cryptography, where the symmetries and operations of groups underpin many secure systems.

% In cryptography, group actions are critical to protocols like Elliptic Curve Cryptography (ECC), which relies on the difficulty of reversing group-based operations to ensure security. Isogeny-based cryptography, a post-quantum cryptographic candidate, uses group actions on elliptic curves to create complex mathematical problems resistant to quantum attacks. Similarly, lattice-based and code-based cryptography use group actions to study transformations in structures that form the basis for secure communication systems. Non-abelian group actions are being explored for their potential to create quantum-resistant algorithms.

% In quantum computing, group actions are central to quantum walks, a quantum equivalent of classical random walks. Quantum walks leverage group actions to describe the evolution of quantum states and exploit the symmetries of these states for tasks like search, optimization, and cryptographic protocol design. This makes them valuable in constructing secure quantum algorithms and protocols, particularly in quantum key distribution and graph-based cryptography. Overall, group actions bridge abstract mathematical theory with practical applications in classical and quantum cryptography.


% \section*{Definition of Group Action}

% Group actions form a bridge between group theory and other mathematical structures, offering a systematic way to study symmetry, transformations, and invariants. Let us delve deeper into their properties, classifications, and applications.

% \subsection*{Formal Definition}

% A \textbf{group action} of a group \( G \) on a set \( X \) is a map \( \cdot : G \times X \to X \) that satisfies:

% \begin{enumerate}
%     \item \textbf{Identity Property}:
%     \[
%     e \cdot x = x \quad \text{for all } x \in X,
%     \]
%     where \( e \) is the identity element of \( G \).

%     \item \textbf{Compatibility (Associativity)}:
%     \[
%     (gh) \cdot x = g \cdot (h \cdot x) \quad \text{for all } g, h \in G, \, x \in X.
%     \]
% \end{enumerate}

% Alternatively, the group action can be viewed as a homomorphism \( \phi : G \to \text{Sym}(X) \), where \( \text{Sym}(X) \) is the group of all permutations of \( X \).

% \subsection*{Types of Group Actions}

% \begin{enumerate}
%     \item \textbf{Faithful Action}: The action is faithful if \( g \cdot x = x \) for all \( x \in X \) implies \( g = e \). Equivalently, the homomorphism \( \phi \) is injective.
    
%     \item \textbf{Transitive Action}: The action is transitive if, for any \( x, y \in X \), there exists \( g \in G \) such that \( g \cdot x = y \). In this case, \( X \) consists of a single orbit.
    
%     \item \textbf{Free Action}: The action is free if \( g \cdot x = x \) implies \( g = e \) for all \( x \in X \).
    
%     \item \textbf{Regular Action}: The action is both transitive and free, meaning there is exactly one \( g \in G \) for each pair \( (x, y) \) such that \( g \cdot x = y \).
    
%     \item \textbf{Effective Action}: The action is effective if the only group element acting as the identity on \( X \) is \( e \).
% \end{enumerate}

% \subsection*{Key Concepts in Group Actions}

% \begin{enumerate}
%     \item \textbf{Orbits}:
%     For \( x \in X \), the \textbf{orbit} of \( x \) is:
%     \[
%     \text{Orb}(x) = \{g \cdot x \mid g \in G\}.
%     \]
%     Orbits partition the set \( X \), and each orbit is a subset where the action appears ``connected.''

%     \item \textbf{Stabilizer Subgroup}:
%     The \textbf{stabilizer} of \( x \in X \) is:
%     \[
%     \text{Stab}_G(x) = \{g \in G \mid g \cdot x = x\}.
%     \]
%     It is a subgroup of \( G \) and describes the symmetries that leave \( x \) unchanged.

%     \item \textbf{Orbit-Stabilizer Theorem}:
%     This theorem links the size of an orbit and its stabilizer:
%     \[
%     |G| = |\text{Orb}(x)| \cdot |\text{Stab}_G(x)|.
%     \]

%     \item \textbf{Fixed Points}:
%     A point \( x \in X \) is a \textbf{fixed point} if \( g \cdot x = x \) for all \( g \in G \). The set of fixed points is:
%     \[
%     \text{Fix}(G) = \{x \in X \mid g \cdot x = x, \, \forall g \in G\}.
%     \]

%     \item \textbf{Invariant Subsets}:
%     A subset \( Y \subseteq X \) is \textbf{invariant} under the action if \( g \cdot y \in Y \) for all \( g \in G \) and \( y \in Y \).
% \end{enumerate}



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section*{Groups and Characters}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Abelian Groups}

% An \textbf{abelian group} (also called a \textbf{commutative group}) is a set \( G \) equipped with a binary operation \( \cdot \) (usually written as addition \( + \) or multiplication \( \cdot \)) that satisfies the following four group axioms, along with an additional \textbf{commutativity} property.

% \subsection{Axioms of an Abelian Group}
% A set \( G \) with a binary operation \( \cdot \) is an \textbf{abelian group} if the following conditions hold:

% \begin{enumerate}
%     \item \textbf{Closure}:  
%     For all \( a, b \in G \), the operation \( a \cdot b \) produces another element in \( G \):

%     \[
%     a \cdot b \in G.
%     \]

%     \item \textbf{Associativity}:  
%     For all \( a, b, c \in G \), the operation satisfies:

%     \[
%     (a \cdot b) \cdot c = a \cdot (b \cdot c).
%     \]

%     \item \textbf{Identity Element}:  
%     There exists an element \( e \in G \) such that for all \( a \in G \):

%     \[
%     e \cdot a = a \cdot e = a.
%     \]

%     This element \( e \) is called the \textbf{identity element}.

%     \item \textbf{Inverse Element}:  
%     For every element \( a \in G \), there exists an element \( a^{-1} \in G \) such that:

%     \[
%     a \cdot a^{-1} = a^{-1} \cdot a = e.
%     \]

%     \item \textbf{Commutativity (Abelian Property)}:  
%     For all \( a, b \in G \), the operation is \textbf{commutative}:

%     \[
%     a \cdot b = b \cdot a.
%     \]

% \end{enumerate}

% Since abelian groups satisfy commutativity, they allow more flexible mathematical operations and structure, leading to applications in algebra, number theory, and topology.



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Characters of Abelian Groups}
% Let \( G \) be an abelian group. A function  

% \[
% \chi: G \to \mathbb{C}^{\times}
% \]

% that maps \( G \) to the group of nonzero complex numbers  \(\mathbb{C}^{\times} = \mathbb{C} \setminus \{0\}\), is called a \textbf{character} of \( G \) if it is a \textbf{group homomorphism}. That is, for all \( g_1, g_2 \in G \), the function satisfies:  

% \[
% \chi(g_1 g_2) = \chi(g_1) \chi(g_2).
% \]

% \section*{Character Values for Finite Groups}

% If \( \chi \) is a character of a finite group (or more generally, a torsion group) \( G \), then each function value \( \chi(g) \) is a root of unity. This follows because, for each \( g \in G \), there exists some integer \( k \in \mathbb{N} \) such that:  

% \[
% g^k = e.
% \]

% Applying \( \chi \) to both sides, we obtain:  

% \[
% \chi(g)^k = \chi(g^k) = \chi(e) = 1.
% \]

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section*{Number of Characters in a Finite Abelian Group}

% A \textbf{finite abelian group} of order \( n \) has exactly \( n \) distinct characters, denoted by:  

% \[
% \chi_1, \chi_2, \dots, \chi_n.
% \]

% The function \( \chi_1 \), defined by:  

% \[
% \chi_1(g) = 1, \quad \forall g \in G,
% \]

% is called the \textbf{principal character} of \( G \). The remaining \( n-1 \) characters are referred to as \textbf{non-principal characters}.




% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section*{Character Group}

% If \( G \) is an abelian group, the set of characters \( \{\chi_k\} \) forms an abelian group under pointwise multiplication, defined as:  

% \[
% (\chi_j \chi_k)(g) = \chi_j(g) \chi_k(g), \quad \forall g \in G.
% \]

% This group is called the \textbf{character group} of \( G \) and is often denoted as $\hat{G}$.  
% The \textbf{identity element} of \( \hat{G} \) is the principal character \( \chi_1 \), and the \textbf{inverse} of a character \( \chi_k \) is its reciprocal:  

% \[
% (\chi_k)^{-1} = \frac{1}{\chi_k}.
% \]

% If \( G \) is finite of order \( n \), then the character group \( \hat{G} \) is also of order \( n \). In this case, since  

% \[
% |\chi_k(g)| = 1, \quad \forall g \in G,
% \]

% the inverse of a character is simply its \textbf{complex conjugate}:

% \[
% \chi_k^{-1}(g) = \overline{\chi_k(g)}.
% \]


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Quantum Fourier Transform}

% The \textbf{Quantum Fourier Transform (QFT)} is one of the most fundamental unitary transformations in quantum computing. It plays a crucial role in quantum algorithms, including Shor’s algorithm for integer factorization and quantum phase estimation. The QFT is the quantum analog of the classical discrete Fourier transform (DFT) but operates on quantum states, enabling efficient quantum computation of Fourier coefficients.

% In this section, we discuss the QFT in the context of abelian groups, with a focus on its implementation over \( \mathbb{Z}_{2^n} \), one of the most commonly used finite groups in quantum algorithms, including quantum walks.

% \section{Quantum Fourier Transform Over an Abelian Group}

% Let \( G \) be an abelian group. The \textbf{Quantum Fourier Transform} over \( G \) is defined as:

% \[
% F_G = \frac{1}{\sqrt{|G|}} \sum_{x \in G} \sum_{y \in \hat{G}} \chi(y,x) | y \rangle \langle x |
% \]

% where:

% \begin{itemize}
%     \item \( \hat{G} \) is a complete set of characters of \( G \).
%     \item \( \chi(y,x) \) denotes the \( y \)th character of \( G \), evaluated at \( x \).
%     \item \( |x\rangle \) and \( |y\rangle \) are quantum states corresponding to elements of \( G \) and its dual group \( \hat{G} \).
% \end{itemize}

% Since \( G \) and \( \hat{G} \) are isomorphic, it is often useful to label the elements of \( \hat{G} \) using elements of \( G \). The unitary nature of the QFT follows from the \textbf{orthogonality of characters}.



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{QFT Over \( \mathbb{Z}_{2^n} \)}

% The QFT over \( G = \mathbb{Z}_{2^n} \) is defined as:

% \[
% F_{\mathbb{Z}_{2^n}} = \frac{1}{\sqrt{2^n}} \sum_{x,y \in \mathbb{Z}_{2^n}} \omega_{2^n}^{xy} | y \rangle \langle x |
% \]

% where:

% \[
% \omega_m = e^{2\pi i / m}
% \]

% is the \textbf{primitive} \( m \)th root of unity. This transformation maps an input basis state \( |x\rangle \) as follows:

% \[
% | x \rangle \to \frac{1}{\sqrt{2^n}} \sum_{y \in \mathbb{Z}_{2^n}} \omega_{2^n}^{xy} | y \rangle.
% \]

% This equation represents a \textbf{linear transformation} where each input state \( |x\rangle \) is mapped to a superposition of all basis states, weighted by phase factors.

% \subsection{Binary Representation and QFT Implementation}

% To implement this transformation efficiently, it is useful to express \( x \) and \( y \) in binary form:

% \[
% x = x_{n-1} x_{n-2} \dots x_1 x_0.
% \]

% The exponent in the Fourier transform formula can then be rewritten using its binary expansion:

% \[
% \omega_{2^n}^{xy} = e^{2\pi i x \sum_{k=0}^{n-1} y_k 2^k / 2^n}.
% \]

% Rewriting the transformation explicitly:

% \[
% | x \rangle \to \frac{1}{\sqrt{2^n}} \sum_{y \in \mathbb{Z}_{2^n}} e^{2\pi i x \sum_{k=0}^{n-1} y_k 2^k / 2^n} | y \rangle.
% \]

% This can be decomposed into a \textbf{tensor product of single-qubit states}, where each qubit state depends on the least significant bits of \( x \):

% \[
% \bigotimes_{k=0}^{n-1} | z_k \rangle.
% \]

% where

% \[
% | z_k \rangle = \frac{1}{\sqrt{2}} ( | 0 \rangle + e^{2\pi i ( x_0 2^{-n+k} + x_1 2^{-n+k+1} + \dots + x_{n-1} 2^{-1} )} | 1 \rangle ).
% \]

% This decomposition highlights the \textbf{hierarchical dependence of qubits on the binary digits of \( x \)}, making it possible to implement the QFT using \textbf{Hadamard gates and controlled phase shift gates}.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection*{Cayley graphs}

% A Cayley graph is a graphical representation of a group based on a chosen set of generators. It is widely used in algebra, combinatorics, and theoretical computer science to study group structures and their applications in network theory, quantum computing, and cryptography.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section*{Definition of Cayley Graphs}

% A \textit{Cayley graph} is a graph that encodes the structure of a group with respect to a chosen generating set. Formally, let \( G \) be a group and \( Q \) be a subset of \( G \) that serves as a generating set, meaning every element of \( G \) can be expressed as a finite product of elements from \( Q \). The Cayley graph \( \Gamma(G, Q) \) is defined as follows. The vertex set of the graph consists of the elements of \( G \), where each vertex corresponds to a unique group element. The edge set is constructed by drawing a directed edge from vertex \( g \) to vertex \( gq \) for each \( g \in G \) and \( q \in Q \). If the generating set \( Q \) is symmetric, meaning that whenever \( q \in Q \), its inverse \( q^{-1} \) is also in \( Q \), then the Cayley graph is undirected; otherwise, it is a directed graph.
% For example, For the cyclic group \( G = \mathbb{Z}_n = \{0,1,2,\dots, n-1\} \) with the generating set \( Q = \{\pm 1\} \), the Cayley graph forms a cycle graph. In this graph, each vertex \( j \) is connected to \( j+1 \mod n \) and \( j-1 \mod n \), creating a cyclic structure.\\


% The adjacency matrix of $\Gamma$ can be expressed as
% \[
% A = \sum_{a \in G} \lambda_a |\hat{a}\rangle \langle \hat{a}|,
% \]
% where $|\hat{a}\rangle$ is the quantum Fourier transform of $|a\rangle$. The eigenvalues $\lambda$ are given by
% \[
% \lambda_a = \sum_{q \in Q} \chi(a, q).
% \]
% Note that the eigenvectors $|\hat{a}\rangle$ of $A$ depend only on $G$ and not on the set $Q$.

% To see this, we have
% \[
%         A\ket{\hat{a}} = A.\frac{1}{\sqrt{|G|}}\sum_{y \in G}\chi(a,y)\ket{y} = \frac{1}{\sqrt{|G|}}\sum_{y \in G}\chi(a,y).A\ket{y}
%         \]
%         \[
%         = \frac{1}{\sqrt{|G|}}\sum_{y \in G}\chi(a,y).\sum_{q \in Q}\ket{qy}
%         \]
%         Consider $\beta = qy$. Then:
%         \[
%          = \frac{1}{\sqrt{|G|}}\sum_{q \in Q}\chi(a,q)\sum_{\beta}\chi(a,\beta)\ket{\beta} = \sum_{q \in Q}\chi(a,q) . \ket{\hat{a}}
%         \]
%         \[
%          = \lambda_a\ket{\hat{a}}
%         \]




% \section*{Quantum walks on Cayley graphs}
% Quantum walks on Cayley graphs play a crucial role in quantum computing, quantum search algorithms, and mathematical physics due to their deep connection with group theory and symmetry. The structured nature of Cayley graphs, derived from group elements and generators, ensures uniform exploration of the graph, leading to faster propagation compared to classical random walks. This property is particularly valuable in quantum algorithms, where quantum walks on Cayley graphs have been used to achieve exponential speedups in search and optimization problems. Additionally, their spectral properties, determined by the adjacency matrix and Fourier analysis on groups, provide insights into mixing times, state localization, and quantum transport phenomena. These advantages make Cayley graphs an essential framework for designing scalable and efficient quantum algorithms, offering a powerful bridge between algebraic structures and quantum mechanics.



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section*{Discrete-Time Quantum Walk on Cayley Graphs}

% A discrete-time quantum walk on a Cayley graph requires a coin operator to maintain unitary evolution.

% \subsection*{State Space}
% The Hilbert space of the quantum walk is:
% \[
% \mathcal{H} = \mathcal{H}_G \otimes \mathcal{H}_C,
% \]
% where:
% \begin{itemize}
%     \item \( \mathcal{H}_G \) is the space spanned by group elements (vertices).
%     \item \( \mathcal{H}_C \) is the coin space, which determines movement directions.
% \end{itemize}

% Each state is represented as:
% \[
% |\psi\rangle = \sum_{g \in G} \sum_{q \in Q} \alpha_{g,q} |g\rangle \otimes |q\rangle,
% \]
% where \( |g\rangle \) is the vertex state and \( |q\rangle \) represents the coin state.

% \subsection*{Evolution Operators}
% \textbf{Coin Flip Operator (\( C \))}: This unitary operator acts on the coin space to create a superposition of movement directions. A common choice is the Grover or Hadamard operator.

% \textbf{Shift Operator (\( S \))}: Moves the walker according to the group structure:
% \[
% S |g\rangle \otimes |s\rangle = |gs\rangle \otimes |s\rangle.
% \]
% This means that if the walker is at vertex \( g \) with a coin state \( s \), it moves to \( gs \).

% \textbf{Full Step Evolution}:
% \[
% U = S (C \otimes I),
% \]
% where \( U \) is the total unitary evolution per step.

% The probability of finding the walker at a particular vertex \( g \) after \( t \) steps is given by:
% \[
% P(g, t) = \sum_{s \in S} |\langle g, s | \psi(t) \rangle |^2.
% \]


% \section*{Continuous-Time Quantum Walk on Cayley Graphs}

% A continuous-time quantum walk on a Cayley graph follows a different evolution, governed by the Hamiltonian.

% \subsection*{Hamiltonian and Evolution}
% The evolution of the quantum walk is determined by the Schrödinger equation:
% \[
% i \frac{d}{dt} |\psi(t)\rangle = H |\psi(t)\rangle.
% \]
% Here, the Hamiltonian \( H \) is usually chosen as:
% \[
% H = A(\Gamma(G,S)),
% \]
% where \( A \) is the adjacency matrix of the Cayley graph:

% \[
% A_{g,h} =
% \begin{cases}
% 1, & \text{if } h = gs \text{ for some } s \in S, \\
% 0, & \text{otherwise}.
% \end{cases}
% \]
%  Alternatively, the Laplacian \( L \) can be used:
% \[
% H = L = D - A,
% \]
% where \( D \) is the degree matrix:

% \[
% D_{ij} =
% \begin{cases}
% \deg(v_i), & \text{if } i = j, \\
% 0, & \text{otherwise}.
% \end{cases}
% \]

% Here, \( \deg(v_i) \) is the degree of vertex \( v_i \), which is the number of edges connected to \( v_i \).


% The solution to the quantum walk is given by:
% \[
% |\psi(t)\rangle = e^{-i H t} |\psi(0)\rangle.
% \]
% This means the probability amplitude at a vertex \( g \) spreads over time according to the unitary evolution operator \( e^{-i H t} \).


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection*{Example: Cyclic Group \( \mathbb{Z}_n \)}

% Consider the Cayley graph of \( \mathbb{Z}_n \) with generator set \( S = \{\pm 1\} \), which forms a cycle graph. The adjacency matrix is:
% \[
% A_{jk} =
% \begin{cases}
% 1, & \text{if } k = j \pm 1 \mod n, \\
% 0, & \text{otherwise}.
% \end{cases}
% \]

% Its eigenvalues are:
% \[
% \lambda_k = 2\cos\left(\frac{2\pi k}{n}\right),
% \]
% with eigenvectors given by the discrete Fourier transform (DFT) basis:
% \[
% \psi_k(j) = e^{\frac{2\pi i k j}{n}}.
% \]

% This result generalizes to other Abelian groups, where the eigenvectors are given by the Fourier basis of the group.


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Simulating continuous-time walks}
% Childs~\cite{childs2010relationship} and Berry, Childs, and Kothari~\cite{berry2015hamiltonian} showed that continuous-time quantum walks can be simulated using discrete-time quantum walks. Since our approach relies on their methods, we begin by outlining the relevant notation and framework.

% Let \( H \) be a Hamiltonian of dimension \( N = 2^n \), and define \( \opnorm{H}_{\mathrm{max}} = \max_{i, j} \abs{H_{ij}} \). To facilitate the simulation, we expand the Hilbert space from \( \C^N \) to \( \C^{2N} \otimes \C^{2N} \) by appending an ancilla qubit initialized to \( \ket{0} \) and duplicating the resulting space.

% To define the discrete-time walk operator, we first construct an orthonormal set of states:
% \begin{align}
%     \ket{\phi_{j0}} & := \frac{1}{\sqrt{d}} \sum_{\ell \in F_j} \ket{\ell} \left( \sqrt{\frac{H_{j\ell}^*}{K}} \ket{0} + \sqrt{1 - \frac{\abs{H_{j\ell}^*}}{K}} \ket{1} \right), \label{eq:walk-sim} \\
%     \ket{\phi_{j1}} & := \ket{0} \ket{1}, \nonumber
% \end{align}
% where \( F_j \) denotes the set of nonzero entries in column \( j \) of \( H \), and \( K \ge \opnorm{H}_{\mathrm{max}} \) is a fixed constant.

% Based on these states, we define the isometry \( T : \C^{2N} \to \C^{2N} \otimes \C^{2N} \) as follows:
% \begin{equation}
%     \label{eq:walk-isom}
%     T := \sum_{j = 0}^{N - 1} \sum_{b \in \{0, 1\}} (\ket{j}\bra{j} \otimes \ket{b}\bra{b}) \otimes \ket{\phi_{jb}}.
% \end{equation}

% The discrete-time quantum walk operator is then defined as
% \[
% W = iS(2TT^* - \mathds{1}),
% \]
% where \( S \) is the swap operator acting as
% \[
% S \ket{j_1} \ket{b_1} \ket{j_2} \ket{b_2} = \ket{j_2} \ket{b_2} \ket{j_1} \ket{b_1},
% \]
% for all \( 0 \le j_1, j_2 < N \) and \( b_1, b_2 \in \{0, 1\} \).

% To efficiently simulate the continuous-time evolution \( e^{-iHt} \), it suffices to implement the isometry \( T \), its adjoint \( T^* \), and the walk operator \( W \) efficiently. Assuming black-box (oracle) access to the entries of \( H \), the following result holds:

% \begin{theorem}[{\cite[Theorem 1]{berry2015hamiltonian}}]
% \label{thm:sparse-sim}
% Let \( H \) be a \( d \)-sparse Hamiltonian acting on \( n \) qubits. Then the unitary \( e^{-iHt} \) can be approximated to within error \( \epsilon \) using
% \[
% O\left( \tau \frac{\log(\tau / \epsilon)}{\log\log(\tau / \epsilon)} \right)
% \]
% queries to \( H \), and
% \[
% O\left( \tau \left[ n + \log^{5 / 2}(\tau / \epsilon) \right] \frac{\log(\tau / \epsilon)}{\log\log(\tau / \epsilon)} \right)
% \]
% additional elementary gates, where \( \tau = d \cdot \opnorm{H}_{\mathrm{max}} \cdot t \).
% \end{theorem}




% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection*{Quantum walks from Group Actions}


% Let \( G \) be an abelian group, and let \( Q = \{q_1, q_2, \dots, q_k\} \subset G \) be a symmetric generating set, meaning that \( q \in Q \) if and only if \( -q \in Q \). The Cayley graph associated with \( G \) and \( Q \) is defined as \( \Gamma = (V, E) \), where the vertex set is \( V = G \), and the edge set consists of all pairs \( (a, b) \in G \times G \) such that \( b = q + a \) for some \( q \in Q \).

% The adjacency matrix \( A \) of \( \Gamma \) admits a spectral decomposition:
% \[
% A = \sum_{a \in G} \lambda_a \ket{\hat{a}} \bra{\hat{a}},
% \]
% where \( \ket{\hat{a}} \) denotes the quantum Fourier transform of \( \ket{a} \), and the eigenvalues \( \lambda_a \) are given by
% \[
% \lambda_a = \sum_{q \in Q} \chi(a, q).
% \]
% Importantly, the eigenvectors \( \ket{\hat{a}} \) depend solely on the group \( G \), not on the choice of the generating set \( Q \).

% Cayley graphs can also be generalized through group actions. Let \( (G, X, *) \) be a regular group action with a fixed element \( x \in X \), and let \( Q = \{q_1, q_2, \dots, q_k\} \subset G \) be a subset as before. Define the Cayley graph \( \Gamma = (X, E) \), where the vertex set is \( X \), and the edge set consists of all pairs \( (x, y) \in X \times X \) such that \( y = q * x \) for some \( q \in Q \).

% The adjacency matrix of this graph can be written as:
% \[
% A = \sum_{h \in G} \lambda_h \ket{G^{(h)} * x} \bra{G^{(h)} * x},
% \]
% where
% \[
% \lambda_h = \sum_{q \in Q} \chi(h, q), \quad \text{and} \quad \ket{G^{(h)} * x} = \frac{1}{\sqrt{|G|}} \sum_{g \in G} \chi(g, h) \ket{g * x}.
% \]

% As in the previous case, the eigenvectors \( \ket{G^{(h)} * x} \) are determined solely by the structure of the group \( G \). This construction generalizes the standard Cayley graph: setting \( X = G \) and the group action \( * \) as group multiplication recovers the original definition.


% To see this, we have:

% \[
%     A\ket{G^{(h)}*x} = \frac{1}{\sqrt{|G|}}.\sum_{g \in G}\chi(g,h) A.\ket{g*x}
%     \]

%     \[
%     = A\ket{G^{(h)}*x} = \frac{1}{\sqrt{|G|}}.\sum_{g \in G}\chi(g,h)\sum_{q \in Q}\ket{q*(g*x)}
%     \]
%     Consider $\beta = qg$. Then:
%     \[
%     = = \frac{1}{\sqrt{|G|}}\sum_{q \in Q}\sum_{\beta \in G}\chi(\beta,h)\chi(q,h)\ket{\beta * x}
%     \]

%     \[
%     = \sum_{q \in Q}\chi(q,h).\ket{G^{(h)}*x} = \lambda_h \ket{G^{(h)}*x}
%     \]

%     Since the group action \( (G, X, *) \) is regular, the two Cayley graph constructions are isomorphic. In the first construction, the vertex set is \( G \), and the adjacency matrix is indexed by elements of \( G \). In the second construction, the vertex set is \( X \), with the adjacency matrix indexed by elements of \( X \). The isomorphism between these graphs is given by the bijection
% \[
% \setlength{\arraycolsep}{1mm}
% \begin{array}{rcll}
% \phi: & G & \longrightarrow & X \\
%       & g & \longmapsto     & g * x,
% \end{array}
% \]

% which maps each group element \( g \in G \) to the corresponding point in its orbit under the action.


%     % Assuming the group action is a cryptographic group action, the isomorphism $\phi$ is a one-way function: given $g \in G$, it is easy to compute $g * x$, whereas given $(x, g * x)$, it is hard to compute $g$. Therefore, although these graphs are mathematically the same, computational problems based on them require fundamentally different techniques. A notable example is the implementation of quantum walks on these graphs.\footnote{Implementations of continuous-time quantum walks in the context of cryptographic group actions have previously appeared in \cite{booher2024failing, doliskani2023sample}, in the setting of supersingular isogeny graphs. These walks can be interpreted as group-action walks.} From this point onward, assume $Q$ is a small set, i.e., $\abs{Q} = \poly(\log \abs{G})$. In the first graph, we can efficiently implement the walks $e^{-iAt}$ even for values of $t$ that are exponentially large in $\log \abs{G}$. This follows from the fact that
%     % \begin{equation}
%     %     \label{eq:adjmat-fb}
%     %     e^{-iAt} = \qft_G \sum_{a \in G} e^{-i\lambda_a t} \ket{a} \bra{a} \qft_G^*.
%     % \end{equation}
%     % The quantum Fourier transform $\qft_G$ and its inverse can be applied in $\poly(\log \abs{G})$ operations. The diagonal unitary in the middle, which is a phase computation $\ket{a} \mapsto e^{-i\lambda_a t} \ket{a}$, is also efficient because $\lambda_a$ can be computed classically to arbitrary precision in $\poly(\log \abs{G})$ time.
    
%     % The situation for group actions is less straightforward. While the states $\ket{G^{(h)} * x}$ are analogous to the states $\ket{\hat{h}}$, the involvement of the action $*$ in the former introduces computational challenges. Specifically, it becomes hard to apply transformations beyond the action $\ket{y} \mapsto \ket{a * y}$ for $a \in G$. Consequently, no decomposition analogous to \eqref{eq:adjmat-fb} exists in the context of group actions. Instead, we are left with the spectral expression
%     % \[ e^{-iAt} = \sum_{h \in G} e^{-i\lambda_h t} \ket{G^{(h)} * x} \bra{G^{(h)} * x}. \]
%     % Despite this limitation, the sparsity and structure of the matrix $A$ allow us to demonstrate in the next section that for $t = \poly(\log \abs{G})$, the walk $e^{-iAt}$ can still be efficiently approximated to polynomial accuracy.   


%     When the group action \( (G, X, *) \) is assumed to be cryptographic, the isomorphism \( \phi \) becomes a one-way function: given \( g \in G \), it is efficient to compute \( g * x \), but given the pair \( (x, g * x) \), it is computationally hard to recover \( g \). As a result, while the two Cayley graphs are mathematically isomorphic, computational tasks associated with them may require fundamentally different approaches. A particularly illustrative example is the implementation of quantum walks on these graphs.\footnote{Continuous-time quantum walks have been explored in the context of cryptographic group actions in~\cite{booher2024failing, doliskani2023sample}, specifically in supersingular isogeny graphs. These walks can be viewed as group-action quantum walks.}

%     From this point forward, we assume the generating set \( Q \) is small, i.e., \( \abs{Q} = \poly(\log \abs{G}) \). In the first construction (where \( X = G \)), the walk \( e^{-iAt} \) can be efficiently implemented even for values of \( t \) that are exponentially large in \( \log \abs{G} \). This is a consequence of the identity:
%     \begin{equation}
%         \label{eq:adjmat-fb}
%         e^{-iAt} = \qft_G \left( \sum_{a \in G} e^{-i\lambda_a t} \ket{a} \bra{a} \right) \qft_G^*,
%     \end{equation}
%     where \( \qft_G \) and its inverse can be implemented in \( \poly(\log \abs{G}) \) time. Moreover, the diagonal phase unitary \( \ket{a} \mapsto e^{-i\lambda_a t} \ket{a} \) is also efficient to implement, since the eigenvalues \( \lambda_a \) can be computed classically to arbitrary precision in \( \poly(\log \abs{G}) \) time.

%     In contrast, the group-action setting presents greater computational difficulty. Although the states \( \ket{G^{(h)} * x} \) play a role analogous to the Fourier basis states \( \ket{\hat{h}} \), the presence of the action \( * \) makes the situation more subtle. In particular, implementing general transformations over these states is difficult; we are typically limited to operations of the form \( \ket{y} \mapsto \ket{a * y} \) for \( a \in G \). As a result, no efficient decomposition similar to~\eqref{eq:adjmat-fb} is known in the group-action setting. Instead, the best we can express is the spectral decomposition:
%     \[
%     e^{-iAt} = \sum_{h \in G} e^{-i\lambda_h t} \ket{G^{(h)} * x} \bra{G^{(h)} * x}.
%     \]

%     Despite this limitation, the adjacency matrix \( A \) retains a high degree of sparsity and algebraic structure. In the next section, we will show that for \( t = \poly(\log \abs{G}) \), the walk \( e^{-iAt} \) can still be efficiently approximated to polynomial accuracy.

%     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    
% \paragraph{Simulating group action quantum walks.}
% Assume \( t = \poly(\log \abs{G}) \). We show that the continuous-time walk \( W = e^{-iAt} \) can be efficiently simulated using the discrete-time quantum walk framework developed in~\cite{childs2010relationship, berry2015hamiltonian}. Recall the isometry \( T \) defined in Equation~\eqref{eq:walk-isom}, where the states \( \ket{\phi_b} \) are as given in Equation~\eqref{eq:walk-sim}. To carry out the simulation, it suffices to show that the isometry \( T \), its adjoint \( T^* \), and the discrete-time walk operator
% \[
% W = iS(2TT^* - \mathds{1})
% \]
% can all be efficiently implemented in the group-action setting.

% Let \( \Gamma = (X, E) \) be the Cayley graph associated with the group action \( (G, X, *) \), and let \( A \) denote its adjacency matrix. The Hamiltonian \( H \) of interest is simply \( A \), indexed by elements of \( X \). In this context, the isometry \( T \) takes the form:
% \begin{align*}
% T
% & := \sum_{y \in X} \sum_{b \in \{0, 1\}} (\ket{y}\bra{y} \otimes \ket{b}\bra{b}) \otimes \ket{\phi_{yb}} \\
% & = \sum_{y \in X} \sum_{b \in \{0, 1\}} \ket{y} \ket{b} \ket{\phi_{yb}} \bra{y} \bra{b}.
% \end{align*}


% Because of the structure of $\Gamma$, the states \eqref{eq:walk-sim} simplify as follows. First, since the set $Q$ is symmetric, the graph $\Gamma$ is undirected and the adjacency matrix $A$ is symmetric with non-negative entries; the nonzero entries of $A$ are all equal to $1$. Therefore, we can set $K = \opnorm{A}_{\mathrm{max}} = 1$. As a result, for $y \in X$, the state $\ket{\phi_{y0}}$ becomes
% \[ \ket{\phi_{y0}} = \frac{1}{\sqrt{\abs{Q}}} \sum_{q \in Q} \ket{q * y} \ket{0}. \]
% We now describe how to implement the isometry \( T \) by constructing efficient unitaries \( U_0 \) and \( U_1 \), where each \( U_b \) acts as
% \[
% U_b : \ket{0} \ket{y, b} \ket{0, 0} \mapsto \ket{0} \ket{y, b} \ket{\phi_{yb}}, \quad b \in \{0, 1\},
% \]
% with the first register serving as an ancilla.

% The unitary \( U_1 \) is straightforward to implement, since \( \ket{\phi_{y1}} = \ket{0} \ket{1} \) is independent of \( y \). We now focus on the construction of \( U_0 \).

% Because \( Q \subset G \) is a small set (i.e., \( \abs{Q} = \poly(\log \abs{G}) \)), we can construct an efficient unitary \( V_Q : \C^Q \to \C^Q \) such that
% \[
% V_Q \ket{0} = \frac{1}{\sqrt{\abs{Q}}} \sum_{q \in Q} \ket{q}.
% \]
% Applying \( V_Q \otimes \mathds{1} \) to the state \( \ket{0} \ket{y, 0} \ket{0, 0} \) produces:
% \[
% \frac{1}{\sqrt{\abs{Q}}} \sum_{q \in Q} \ket{q} \ket{y, 0} \ket{0, 0}.
% \]

% Next, we apply the unitary \( V_1 \), defined by:
% \[
% V_1 : \ket{q} \ket{y, 0} \ket{0, 0} \mapsto \ket{q} \ket{y, 0} \ket{q * y, 0}.
% \]

% Following this, we uncompute the first register to recover \( \ket{0} \ket{y, 0} \ket{\phi_{y0}} \). This is achieved by applying the unitary \( V_2 \), defined as:
% \[
% V_2 : \ket{q} \ket{y, 0} \ket{q * y, 0} \mapsto \ket{0} \ket{y, 0} \ket{q * y, 0}.
% \]
% Since \( Q \) is small, we can efficiently determine \( q \) from the pair \( (y, q * y) \) by exhaustively checking each \( q \in Q \). Thus, \( V_2 \) (and therefore \( U_0 \)) can be implemented efficiently.


% To implement \( U_0^* : \ket{0} \ket{y, 0} \ket{\phi_{y0}} \mapsto \ket{0} \ket{y, 0} \ket{0, 0} \), we sequentially apply \( V_2^* \), followed by \( V_1^* \), and finally \( V_Q^* \otimes \mathds{1} \). Since each of these unitaries can be implemented efficiently, it follows that \( U_0^* \) is also efficient.

% We now construct the isometry \( T \) using a conditional unitary \( U_T \), which applies either \( U_0 \) or \( U_1 \) depending on the value of the qubit \( b \). That is,
% \[
% U_T = \text{Controlled-}U_b \quad \text{with control on } b \in \{0,1\}.
% \]

% Next, we demonstrate that the walk unitary
% \[
% W = iS(2TT^* - \mathds{1})
% \]
% can be applied efficiently. This reduces to implementing the reflection \( 2TT^* - \mathds{1} \), which we analyze as follows:
% \begin{align*}
% 2\ket{0}\bra{0} \otimes TT^* - \mathds{1}
% &= 2\ket{0}\bra{0} \otimes \sum_{y \in X} \sum_{b \in \{0,1\}} \ket{y,b} \ket{\phi_{yb}} \bra{y,b} \bra{\phi_{yb}} - \mathds{1} \\
% &= 2\sum_{y \in X} \sum_{b \in \{0,1\}} \ket{0} \ket{y,b} \ket{\phi_{yb}} \bra{0} \bra{y,b} \bra{\phi_{yb}} - \mathds{1} \\
% &= U_T \left( 2 \sum_{y \in X} \sum_{b \in \{0,1\}} \ket{0} \ket{y,b} \ket{0,0} \bra{0} \bra{y,b} \bra{0,0} - \mathds{1} \right) U_T^* \\
% &= U_T \left( 2\ket{0}\bra{0} \otimes \mathds{1}_{X,b} \otimes \ket{0,0}\bra{0,0} - \mathds{1} \right) U_T^*.
% \end{align*}

% Since \( U_T \), \( U_T^* \), and the operator \( 2\ket{0}\bra{0} \otimes \mathds{1}_{X,b} \otimes \ket{0,0}\bra{0,0} - \mathds{1} \) can all be implemented efficiently, it follows that the reflection \( 2\ket{0}\bra{0} \otimes TT^* - \mathds{1} \) is also efficient.

% Finally, for any input state \( \ket{\psi} \), the reflection acts as:
% \[
% \left(2\ket{0}\bra{0} \otimes TT^* - \mathds{1} \right) \ket{0} \ket{\psi} = \ket{0} \left(2TT^* - \mathds{1} \right) \ket{\psi},
% \]
% confirming that the full walk operator \( W \) can be implemented efficiently in the group-action setting.










% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Applicaions}
% \section{Quantum Money}
% \section*{Introduction to Quantum Money}
% Quantum money is a revolutionary concept in cryptography that uses quantum mechanics to create a form of currency that is provably secure against forgery. Originally introduced by physicist Stephen Wiesner in the 1970s, quantum money represents one of the earliest proposed applications of quantum information science. By encoding information into quantum states, quantum money exploits the fundamental principles of quantum mechanics to provide security features unattainable by classical systems.

% % \section*{How Quantum Money Works}
% % At its core, quantum money relies on two key principles of quantum mechanics: the \textit{no-cloning theorem} and the \textit{observer effect}.

% % \subsection*{Encoding Information in Quantum States}
% % \begin{itemize}
% %     \item Each quantum bill contains a unique quantum state, such as a set of qubits encoded in superposition.
% %     \item These states are generated and stored by the issuing authority (e.g., a central bank) using a secret algorithm.
% % \end{itemize}

% % \subsection*{Verification Process}
% % \begin{itemize}
% %     \item The issuing authority also generates a verification protocol, allowing a legitimate quantum bill to be authenticated.
% %     \item When a user presents a quantum bill for verification, the authority measures the encoded quantum states using the pre-determined protocol.
% %     \item If the measured states align with the expected values, the bill is deemed valid.
% % \end{itemize}

% % \subsection*{Unforgeability}
% % \begin{itemize}
% %     \item Due to the \textit{no-cloning theorem}, it is impossible to copy an unknown quantum state without altering it.
% %     \item Any attempt to measure or duplicate the quantum state results in a disturbance detectable during verification.
% % \end{itemize}

% % \section*{Key Principles Underpinning Quantum Money}
% % \begin{enumerate}
% %     \item \textbf{No-Cloning Theorem:} The no-cloning theorem states that an unknown quantum state cannot be perfectly copied. This makes quantum money inherently secure, as counterfeiters cannot reproduce the quantum states encoded in legitimate currency.
% %     \item \textbf{Measurement Disturbance:} Observing or measuring a quantum state generally alters it. This ensures that any unauthorized attempt to inspect the quantum money will render it invalid, as the encoded states will no longer match their original form.
% %     \item \textbf{Randomness and Superposition:} Quantum money utilizes superposition to encode information. For example, a single qubit in superposition may represent both $0$ and $1$ simultaneously until measured. The randomness of these states makes predicting or reproducing them without knowledge of the original encoding impossible.
% %     \item \textbf{Entanglement (Optional Feature):} Some implementations of quantum money involve quantum entanglement, where pairs of quantum states are interconnected. Changes to one entangled state directly affect its pair, adding another layer of security against forgery.
% % \end{enumerate}


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section*{Benefits of Quantum Money}
% \begin{itemize}
%     \item \textbf{Unforgeable:} Classical currency, both physical and digital, can be counterfeited with enough effort and resources. Quantum money, however, is fundamentally unforgeable due to the laws of quantum physics.
%     \item \textbf{Decentralized Verification:} In some theoretical models, quantum money can be verified without contacting the issuing authority, enabling decentralized systems for authentication.
%     \item \textbf{Enhanced Privacy:} The unique encoding of each quantum bill could allow for privacy-preserving transactions, as the details of the transaction need not be linked to the bill's verification.
% \end{itemize}



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Quantum Money From Group Actions}
% A public-key quantum money scheme consists of two QPT algorithms: 
% \begin{itemize}
% \item $\gen(1^\lambda)$: This algorithm takes a security parameter $\lambda$ as input and outputs a pair $(s, \rho_s)$, where $s$ is a binary string called the serial number, and $\rho_s$ is a quantum state called the banknote. The pair $(s, \rho_s)$, or simply $\rho_s$, is sometimes denoted by $\$$.
% \item $\ver(s, \rho_s)$ This algorithm takes a serial number and an alleged banknote as input and outputs either $1$ (accept) or $0$ (reject).
% \end{itemize}

% The quantum money scheme is said to be \textit{correct} if genuine banknotes generated by $\gen$ are accepted by $\ver$ with high probability. More formally:
% \[ \Pr[\ver(s, \rho_s) = 1 : (s, \rho_s) \gets \gen(1^\lambda)] \ge 1 - \negl(\lambda). \]
% where the probability is taken over the randomness of $\gen$ and $\ver$. The scheme $(\gen, \ver)$ is said to be secure if, given a genuine bill $(s, \rho_s)$, no QPT algorithm $\mathcal{A}$ can produce two (possibly entangled) bills $(s, \rho_1)$ and $(s, \rho_2)$ that are both accepted by $\ver$ with non-negligible probability. More formally:
% \[ \Pr\left[ \ver(s, \rho_1) = \ver(s, \rho_2) = 1 : \substack{(s, \rho_s) \gets \gen(1^\lambda) \\ (\rho_1, \rho_2) \gets \mathcal{A}(s, \rho_s)} \right] \le \negl(\lambda). \]

% We now briefly outline the quantum money construction from \cite{zhandry2024quantum}, which is based on abelian group actions. We will the $\comph$ algorithm:
% \paragraph{The $\comph$ Algorithm.}
% Given access to the state $\ket{G^{(h)} * x}$, one can efficiently recover the value of $h$ via a quantum algorithm. In particular, there exists a unitary transformation that maps
% \[
% \ket{G^{(h)} * x} \ket{0} \mapsto \ket{G^{(h)} * x} \ket{h},
% \]
% leveraging the technique of \textit{phase kickback}. The process proceeds as follows:

% Begin with the state $\ket{G^{(h)} * x} \ket{0}$ and apply the quantum Fourier transform (QFT) to the second register. Then apply the unitary operator
% \[
% \sum_{k \in G} U_k \otimes \ket{k}\bra{k}
% \]
% to both registers. This operation encodes the character information into the phase, resulting in the state
% \[
% \frac{1}{\sqrt{\abs{G}}} \sum_{k \in G} \ket{G^{(h)} * x} \chi(-k, h) \ket{k}.
% \]
% Finally, applying the inverse QFT to the second register disentangles the phase and reveals $h$, yielding the final state $\ket{G^{(h)} * x} \ket{h}$.

% \vspace{0.5cm}
% Let $\{(G_\lambda, X_\lambda, *)\}_{\lambda \in J}$, where $J \subset \N$, be a collection of cryptographic group actions for abelian groups $G_\lambda$, and let $x_\lambda \in X_\lambda$ be a fixed element. The $\gen$ and $\ver$ algorithms are as follows:
% \begin{itemize}
% \item $\gen(1^\lambda)$. Begin with the state $\ket{0}\ket{x_\lambda}$, and apply the quantum Fourier transform over $G_\lambda$ to the first register producing the superposition
%     \[ \frac{1}{\sqrt{\abs{G_\lambda}}} \sum_{g \in G_\lambda} \ket{g}\ket{x_\lambda}. \]
%     Next, apply the unitary transformation $\ket{h}\ket{y} \mapsto \ket{h}\ket{h * y}$ to this state, followed by the quantum Fourier transform on the first register. This results in
%     \[ \frac{1}{\abs{G_\lambda}} \sum_{h \in G_\lambda} \sum_{g \in G_\lambda} \chi(g, h) \ket{h}\ket{g * x_\lambda} = \frac{1}{\sqrt{\abs{G_\lambda}}} \sum_{h \in G_\lambda} \ket{h} \ket{G^{(h)} * x_\lambda} \]
%     where,
%     \[
%     \ket{G^{(h)}*x_\lambda} = \frac{1}{\sqrt{|G_\lambda|}}\sum_{g \in G_\lambda}\chi(g,h)\ket{g*x_\lambda}
%     \]
%     . Measure the first register to obtain a random $h \in G_\lambda$, collapsing the state to $\ket{G^{(h)} * x_\lambda}$. Return the pair $(h, \ket{G^{(h)} * x_\lambda})$.

% \item $\ver(h, \ket{\psi})$. First, check whether $\ket{\psi}$ has support in $X_\lambda$. If not, return $0$. Then, apply $\comph$ to the state $\ket{\psi}\ket{0}$, and measure the second register to obtain some $h' \in G_\lambda$. If $h' = h$, return $1$; otherwise return $0$.
% \end{itemize}

% From this point forward, to simplify the notation, we make the security parameter $\lambda$ implicit, and use $G$ for $G_\lambda$, $X$ for $X_\lambda$, and so on. 




% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section*{Quantum Hartley Transform (QHT)}

% The \textbf{Quantum Hartley Transform (QHT)} is a linear unitary transform that operates on quantum states. It transforms the basis states \( |x\rangle \) as follows:
% \[
% |x\rangle \xrightarrow{\text{QHT}} \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \text{cas}\left(\frac{2\pi x k}{N}\right) |k\rangle
% \]
% where:
% \begin{itemize}
%     \item \( x \) and \( k \) are integers in \( \{0, 1, \dots, N-1\} \),
%     \item \( \text{cas}(x) = \cos(x) + \sin(x) \),
%     \item \( N \) is the dimension of the transform, typically \( 2^n \) for \( n \)-qubit systems.
% \end{itemize}

% For a quantum state \( |\psi\rangle \) in an \( N \)-dimensional Hilbert space, represented as:
% \[
% |\psi\rangle = \sum_{x=0}^{N-1} \psi_x |x\rangle,
% \]
% the QHT transforms the state into:
% \[
% |\psi'\rangle = \text{QHT} |\psi\rangle = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \left( \sum_{x=0}^{N-1} \psi_x \, \text{cas}\left(\frac{2\pi x k}{N}\right) \right) |k\rangle.
% \]


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection*{Properties of the QHT}
% \begin{enumerate}
%     \item \textbf{Unitary Transformation}: The QHT matrix \( U_{\text{QHT}} \) is unitary:
%     \[
%     U_{\text{QHT}} U_{\text{QHT}}^\dagger = I,
%     \]
%     preserving quantum state normalization.
%     \item \textbf{Symmetry}: The QHT is symmetric because \( \text{cas}(x) = \text{cas}(-x) \).
%     \item \textbf{Efficient Implementation}: Like the Quantum Fourier Transform (QFT), the QHT can be implemented with \( O(\log^2 N) \) gates for \( N = 2^n \).
% \end{enumerate}

% % \subsection*{Comparison with the Quantum Fourier Transform (QFT)}
% % The QFT and QHT differ in their transformation kernels:
% % \begin{itemize}
% %     \item \textbf{QFT}:
% %     \[
% %     |x\rangle \xrightarrow{\text{QFT}} \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{2\pi i x k / N} |k\rangle.
% %     \]
% %     \item \textbf{QHT}:
% %     \[
% %     |x\rangle \xrightarrow{\text{QHT}} \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \left[\cos\left(\frac{2\pi x k}{N}\right) + \sin\left(\frac{2\pi x k}{N}\right)\right] |k\rangle.
% %     \]
% % \end{itemize}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection*{Efficient implementation of Heartly transform}

% % Our algorithm for the quantum Hartley transform, $\qht_N$, is inspired by the recursive algorithm for computing the quantum Fourier transform ($\qft_N$). Let us briefly explain how the algorithm for $\qft_N$ works. For simplicity, we assume $N = 2^n$, so that elements of $\Z_N$ are represented using exactly $n$ qubits. The generalization to arbitrary $N$ can be achieved by following the same recursive approach. Given $a \in \Z_N$, the expression for $\qft_N$ is written as follows:

% Our algorithm for the quantum Hartley transform, \( \qht_N \), is modeled after the recursive structure of the quantum Fourier transform algorithm \( \qft_N \). To motivate this, we begin by reviewing the standard approach for computing \( \qft_N \). For clarity, we assume \( N = 2^n \), allowing each element of \( \Z_N \) to be represented using exactly \( n \) qubits. The same recursive framework can be extended to handle general values of \( N \). For any \( a \in \Z_N \), the quantum Fourier transform is defined as:


% \begin{align*}
%     \qft_N\ket{a}
%     & = \frac{1}{\sqrt{N}} \sum_{y = 0}^{N - 1} \omega_N^{ay}\ket{y} \\
%     & = \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \omega_N^{ay} \ket{y} + (-1)^a \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \omega_N^{ay} \ket{y + N/2} \\
%     & = \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \omega_N^{ay} \frac{1}{\sqrt{2}} (\ket{0} + (-1)^a \ket{1}) \ket{y}, \numberthis\label{eq:qft_alt}
% \end{align*}


% In the final expression, we have isolated the first qubit for clarity. Let \( \ket{a} = \ket{t}\ket{b} \), where \( b \) denotes the least significant bit of \( a \), implying that \( a = 2t + b \) for some \( t \in \Z_{N / 2} \). Applying \( \qft_{N / 2} \) to the first register yields the state:

% \[ \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \omega_N^{2ty} \ket{y} \ket{b}. \]
% Next, we apply the phase unitary \( P(y, b) \), defined by \( \ket{y} \ket{b} \mapsto \omega_N^{by} \ket{y} \ket{b} \), followed by a Hadamard transform on the final qubit. This results in the state given in Equation~\eqref{eq:qft_alt}.


% We now describe our algorithm for efficiently computing the quantum Hartley transform \( \qht_N \). The key idea is to leverage the recursive structure of \( \qht_N \), analogous to the strategy used for \( \qft_N \). To facilitate this, we begin by rewriting the summation in Equation~\eqref{eq:qht-N} to expose its recursive form. Our approach is as follows:
% \begin{equation}
%     \label{eq:cas-expand}
% 	\frac{1}{\sqrt{N}} \sum_{y = 0}^{N - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \ket{y}
%     = \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \ket{y} + \frac{1}{\sqrt{N}} \sum_{y = N / 2}^{N - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \ket{y}.
% \end{equation}



% The second summation on the right-hand side can be expressed as:
% \begin{align*}
% 	\sum_{y = N / 2}^{N - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \ket{y}
%     & = \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi a y}{N} + \pi a \Big) \ket{y + N/2} \\
%     & = (-1)^a \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \ket{y + N/2},
% \end{align*}
% The second equality follows from the angle-sum identity for the \( \cas \) function,
% \[
% \cas(\alpha + \beta) = \cos(\alpha)\cas(\beta) + \sin(\alpha)\cas(-\beta),
% \]
% along with the fact that \( \cos(\pi a) = (-1)^a \) for all integers \( a \). Substituting this into Equation~\eqref{eq:cas-expand} yields:
% \begin{align}
% 	\frac{1}{\sqrt{N}} \sum_{y = 0}^{N - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \ket{y}
%     & = \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi a y}{N} \Big) (\ket{y} + (-1)^a \ket{y + N/2}) \nonumber \\
%     & = \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi a y}{N} \Big) \frac{1}{\sqrt{2}} (\ket{0} + (-1)^a \ket{1}) \ket{y}, \label{eq:qht-alt} 
% \end{align}
% In the final equality, the most significant qubit has been isolated to emphasize its contribution to the overall transformation.

% We now demonstrate how to compute \( \qht_N \) recursively. For a given \( a \in \Z_N \), we decompose the basis state as \( \ket{a} = \ket{t}\ket{b} \), where \( b \) denotes the least significant bit, such that \( a = 2t + b \) for some \( t \in \Z_{N/2} \). Assuming the existence of an efficient quantum circuit for computing \( \qht_{N/2} \), we proceed to construct \( \qht_N \) in a recursive fashion. To begin the transformation on \( \ket{a} \), we introduce an ancilla qubit initialized to \( \ket{0} \), yielding the joint state \( \ket{0}\ket{t}\ket{b} \). We then proceed as follows:
% \begin{align*}
% 	\ket{0}\ket{t}\ket{b}
%     & \mapsto \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi t y}{N / 2} \Big) \ket{0} \ket{y} \ket{b} & (\mathds{1} \otimes \qht_{N / 2} \otimes \mathds{1}) \\
%     & = \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{4\pi t y}{N} \Big) \ket{0} \ket{y} \ket{b} \\
%     & \mapsto \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{4\pi t y}{N} \Big) (\ket{0} + \ket{1}) \ket{y}\ket{b}. & (H \otimes \mathds{1})
% \end{align*}
% Next, we apply a controlled negation operation, where the ancilla qubit is flipped if and only if the least significant bit \( b \) is equal to 1.
% \[
%     V: \ket{0}\ket{y} \mapsto \ket{0}\ket{y}, \quad \ket{1}\ket{y} \mapsto \ket{1}\ket{N / 2 -y},
% \]
% \[
%     \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{4\pi t y}{N} \Big) \ket{0} \ket{y} \ket{b} + \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{4\pi t y}{N} \Big) \ket{1} \ket{-y} \ket{b}.
% \]
% By performing a change of variables in the second summation and using the identity \( \cas\left(\frac{4\pi t (N / 2 - y)}{N}\right) = \cas\left(-\frac{4\pi t y}{N}\right) \), we obtain the state:
% \[
%     \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \Big( \cas\Big( \frac{4\pi t y}{N} \Big) \ket{0} + \cas\Big( -\frac{4\pi t y}{N} \Big) \ket{1} \Big) \ket{y} \ket{b}.
% \]

% We define the single-qubit rotation \( R(\theta) \) as the unitary operator acting on a single qubit given by:\begin{equation}
%     \label{eq:sine-rot}
%     R(y, b) = 
%     \begin{bmatrix}
%         \cos(2\pi b y / N) & \sin(2\pi b y / N) \\
%         -\sin(2\pi b y / N) & \cos(2\pi b y / N)
%     \end{bmatrix},
% \end{equation}
% Now, consider the unitary \( U_R \) defined by
% \[
% U_R : \ket{c}\ket{y}\ket{b} \mapsto \left(R(y, b)\ket{c}\right)\ket{y}\ket{b},
% \]
% where \( R(y, b) \) is a single-qubit rotation depending on \( y \) and \( b \). Applying \( U_R \) followed by the controlled negation \( V \), we obtain the state:
% \begin{align*}
%     \ket{\phi_1}
%     & = \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \Big( \cas\Big( \frac{2\pi ay}{N} \Big) \ket{0} + \cas\Big(-\frac{2\pi a(N /2 - y)}{N} \Big) \ket{1} \Big) \ket{y} \ket{b} \\
%     & = \frac{1}{\sqrt{N}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi ay}{N} \Big) \Big( \ket{0} + (-1)^b \ket{1} \Big) \ket{y} \ket{b},
% \end{align*}
% Here, we have used the identity \( \cas\left(-\pi a + \frac{2\pi a y}{N}\right) = (-1)^a \cas\left(\frac{2\pi a y}{N}\right) \), along with the fact that \( (-1)^a = (-1)^b \). Applying the Hadamard transform to the first qubit yields:
% \[
%     \ket{\psi} = \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi ay}{N} \Big) \ket{b} \ket{y} \ket{b}
% \]
% Next, we uncompute the first qubit by applying a \textsc{CNOT} gate with the last qubit as control. We then apply a Hadamard transform followed by a swap operation, resulting in the state:
% \begin{align*}
%     \ket{\psi}
%     & \mapsto \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi ay}{N} \Big) \ket{0} \ket{y} \ket{b} & (\textsc{cnot}) \\
%     & \mapsto \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi ay}{N} \Big) \ket{0} \ket{y} \frac{1}{\sqrt{2}}(\ket{0} + (-1)^b \ket{1}) & (\mathds{1} \otimes H) \\
%     & = \frac{1}{\sqrt{N / 2}} \sum_{y = 0}^{N / 2 - 1} \cas\Big( \frac{2\pi ay}{N} \Big) \ket{0} \ket{y} \frac{1}{\sqrt{2}}(\ket{0} + (-1)^a \ket{1}). & ((-1)^b = (-1)^a) \\
% \end{align*}
% The final summation matches precisely with Equation~\eqref{eq:qht-alt}, which defines the quantum Hartley transform of \( \ket{a} \). Thus, we have successfully implemented the transformation:
% \[
% \ket{a} \mapsto \qht_N \ket{a}.
% \]
% \[ \ket{0}\ket{a} \mapsto \ket{0} \qht_N\ket{a}. \]
% The complete procedure is summarized in the following algorithm.

% \begin{algorithm}[$\qht_N$] \
%     \label{alg:qht-N}
%     \begin{description}[font = \normalfont\itshape, itemsep = 0mm, parsep = 0mm, topsep = 1mm]
%         \item [Input:] quantum state $\ket{\psi} \in \C^N$, where $N = 2^n$
%         \item [Output:] quantum state $\qht_N\ket{\psi}$
%     \end{description}

%     \begin{enumerate}[itemsep = 0mm, parsep = 1mm, topsep = 1mm]
%         \item Initialize an ancilla qubit to $0$ to obtain the state $\ket{0}\ket{\psi}$
%         \item Compute $\mathds{1} \otimes \qht_{N / 2} \otimes \mathds{1}$ recursively.
%         \item Apply $H \otimes \mathds{1}$.
%         \item\label{stp:ngt} Apply the controlled negation $\ket{0}\ket{y} \mapsto \ket{0}\ket{y}, \ket{1}\ket{y} \mapsto \ket{1}\ket{N / 2 -y}$ to the first two registers.
%         \item Apply the unitary $U_R$.
%         \item Apply $H \otimes \mathds{1}$
%         \item Apply \textsc{cnot} to the first and last qubits.
%         \item Apply $\mathds{1} \otimes H$.
%         \item Trace out the first qubit
%     \end{enumerate}
% \end{algorithm}


% \begin{theorem}
%     \label{thm:qht-cost}
%     Algorithm \ref{alg:qht-N} is correct and can be implemented using $\approx \log^2 N + O(\log N)$ elementary gates.
% \end{theorem}


% \begin{proof}
%     The correctness of the algorithm follows from the preceding discussion. Except for the unitary \( U_R \) and the negation unitary in Step~\ref{stp:ngt}, all steps of the algorithm can be implemented using \( O(1) \) elementary gates. The negation operation in Step~\ref{stp:ngt} can be realized using approximately \( \lceil \log N \rceil \) elementary gates.
    
%     To implement the unitary \( U_R \), which requires constructing the conditional rotation operator \( R(y, b) \) for arbitrary \( y \) and \( b \), we make use of the two-qubit controlled rotations:
%     \[
%     R_j = \ket{0}\bra{0} \otimes \mathds{1} + \ket{1}\bra{1} \otimes
%     \begin{bmatrix}
%     \cos\left(\frac{2\pi 2^j}{N}\right) & \sin\left(\frac{2\pi 2^j}{N}\right) \\
%     -\sin\left(\frac{2\pi 2^j}{N}\right) & \cos\left(\frac{2\pi 2^j}{N}\right)
%     \end{bmatrix},
%     \]
%     for \( j = 0, 1, \dots, n - 1 \). When \( b = 0 \), we have \( R(y, 0) = \mathds{1} \), and when \( b = 1 \), the operator \( R(y, 1) \) is the product of those \( R_j \) for which the \( j \)th bit of \( y \) is 1. Therefore, for a binary string \( y \) of length \( k = \lceil \log y \rceil \), we can implement \( U_R \) using at most \( k \) gates from the set \( \{R_j\} \).
    
%     Let \( T(N) \) denote the gate complexity of Algorithm~\ref{alg:qht-N} for an input of dimension \( N \). Assuming access to the \( R_j \) gates as elementary operations, the recurrence relation becomes
%     \[
%     T(N) \approx T(N / 2) + 2\log N + O(1).
%     \]
%     Solving this recurrence yields \( T(N) \approx \log^2 N + O(\log N) \), as claimed.
%     \end{proof}
    



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Quantum Money With The Hartley Transform}
% \label{sec:qm_hartley}

% The quantum money scheme described earlier can also be instantiated using the quantum Hartley transform in place of the quantum Fourier transform. However, this substitution disrupts the original verification procedure. In the following sections, we demonstrate how quantum walks can be employed to resolve this issue. To pinpoint the source of the problem, we begin by restating the \( \gen \) and \( \ver \) algorithms for this Hartley-based scheme, mirroring the structure of the Fourier-based version but replacing \( \qft_G \) with \( \qht_G \). For simplicity, we take \( G = \Z_N \), and fix an element \( x \in \Z_N \).

% \begin{itemize}
%     \item \textbf{\( \gen \)}: Start with the state \( \ket{0}\ket{x} \), and apply the quantum Hartley transform over \( \Z_N \) to the first register, resulting in the superposition
%     \[
%     \frac{1}{\sqrt{N}} \sum_{g \in \Z_N} \ket{g}\ket{x}.
%     \]
%     Next, apply the unitary transformation \( \ket{h}\ket{y} \mapsto \ket{h}\ket{h * y} \), followed by a Hartley transform \( \qht_N \) on the first register. This yields the state
%     \[
%     \frac{1}{N} \sum_{h \in \Z_N} \sum_{g \in \Z_N} \cas\left(\frac{2\pi gh}{N}\right) \ket{h}\ket{g * x}
%     = \frac{1}{\sqrt{N}} \sum_{h \in \Z_N} \ket{h} \ket{\Z_N^{(h)} * x}_H,
%     \]
%     where
%     \[
%     \ket{\Z_N^{(h)} * x}_H = \frac{1}{\sqrt{N}} \sum_{g \in \Z_N} \cas\left(\frac{2\pi gh}{N}\right) \ket{g * x}.
%     \]
%     Measure the first register to obtain a random \( h \in \Z_N \), collapsing the state to \( \ket{\Z_N^{(h)} * x}_H \). Return the pair \( (h, \ket{\Z_N^{(h)} * x}_H) \).

%     \item \textbf{\( \ver(h, \ket{\psi}) \)}: First, check whether \( \ket{\psi} \) has support in \( X \). If not, return \( 0 \). Otherwise, apply \( \comph \) to the state \( \ket{0} \ket{\psi} \), and measure the first register to obtain some \( h' \in \Z_N \). Return \( 1 \) if \( h' = h \), and \( 0 \) otherwise.
% \end{itemize}


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section*{Verification using quantum walks}


% Given a state of the form $\ket{\Z_N^{(h)} * x}_H$, we demonstrate how the value of $h$ can be extracted using continuous-time quantum walks. For any $u \in \Z_N$, consider the Cayley graph $\Gamma = (\Z_N, E)$ generated by $Q = {\{-u, u}\}$. Let $A$ denote the adjacency matrix of $\Gamma$. The eigenvectors of $A$ are given by $\ket{\Z_N^{(h)} * x}$, with corresponding eigenvalues $\lambda_h = 2\cos(2\pi uh / N)$ for each $h \in \Z_N$. According to Theorem \ref{thm:sparse-sim} and the discussion that follows, the unitary evolution operator $W = e^{iAt}$ can be simulated efficiently to exponential precision. To proceed, we first state the following lemma.




% \begin{lemma}
%     \label{lem:h-eigen}
%     The money state $\ket{\Z_N^{(h)} * x}_H$ is an eigenstate of $W$ with eigenvalue $e^{i\lambda_h t}$.
% \end{lemma}
% \begin{proof}
%     We have 
%     \begin{align*}
%         e^{iAt} \ket{\Z_N^{(h)} * x}_H
%         & = \sum_{g \in \Z_N} e^{i\lambda_gt} \ket{\Z_N^{(g)} * x} \braket{\Z_N^{(g)} * x}{\Z_N^{(h)} * x}_H \\
%         & = \sum_{g \in \Z_N} e^{i\lambda_gt} \ket{\Z_N^{(g)} * x} \bra{\Z_N^{(g)} * x} \Big( \frac{1 - i}{2} \ket{\Z_N^{(h)} * x} + \frac{1 + i}{2} \ket{\Z_N^{(-h)} * x} \Big) \\
%         & = e^{i\lambda_{h}t} \frac{1 - i}{2} \ket{\Z_N^{(h)} * x} + \frac{1 + i}{2} e^{i\lambda_{-h}t} \ket{\Z_N^{(-h)} * x} \\
%         & = e^{i\lambda_{h}t} \ket{\Z_N^{(h)} * x}_H,
%     \end{align*}
%     where the second equality follows from the identity in \eqref{eq:ht-ft}, and the last equality follows from the fact that $\lambda_h = \lambda_{-h}$.
% \end{proof}


% By setting \( t = \poly(\log N) \), Lemma~\ref{lem:h-eigen} ensures that phase estimation can be performed using the unitary \( W \) and the eigenstate \( \ket{\Z_N^{(h)} * x}_H \), yielding an approximation \( \tilde{\lambda}_h \) of \( \lambda_h \) such that
% \[
% \abs{\tilde{\lambda}_h - \lambda_h} \le \frac{1}{\poly(\log N)}.
% \]
% From this approximation, we can extract a real number \( 0 \le \theta \le 1 \) satisfying
% \[
% \abs*{\theta - \frac{uh}{N}} \le \frac{1}{\poly(\log N)}.
% \]
% Since phase estimation can be applied with various choices of \( u \), we can obtain multiple approximations of \( \frac{uh}{N} \). As shown in~\cite{zhandry2024quantum}, selecting \( u \) appropriately allows us to reconstruct \( h \) exactly from these estimates.









% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \newpage
% \bibliographystyle{plain}
% \bibliography{references}







\end{document}

